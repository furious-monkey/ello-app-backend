// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: banned.tl.proto

package banned

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	mtproto "github.com/teamgram/proto/mtproto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TLConstructor int32

const (
	CRC32_UNKNOWN                       TLConstructor = 0
	CRC32_banned_checkPhoneNumberBanned TLConstructor = -515891261
	CRC32_banned_getBannedByPhoneList   TLConstructor = -453047268
	CRC32_banned_ban                    TLConstructor = 1037800024
	CRC32_banned_unBan                  TLConstructor = 1912613348
)

var TLConstructor_name = map[int32]string{
	0:          "CRC32_UNKNOWN",
	-515891261: "CRC32_banned_checkPhoneNumberBanned",
	-453047268: "CRC32_banned_getBannedByPhoneList",
	1037800024: "CRC32_banned_ban",
	1912613348: "CRC32_banned_unBan",
}

var TLConstructor_value = map[string]int32{
	"CRC32_UNKNOWN":                       0,
	"CRC32_banned_checkPhoneNumberBanned": -515891261,
	"CRC32_banned_getBannedByPhoneList":   -453047268,
	"CRC32_banned_ban":                    1037800024,
	"CRC32_banned_unBan":                  1912613348,
}

func (x TLConstructor) String() string {
	return proto.EnumName(TLConstructor_name, int32(x))
}

func (TLConstructor) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_aa4d21e2e5430b9c, []int{0}
}

//--------------------------------------------------------------------------------------------
// banned.checkPhoneNumberBanned phone:string = Bool;
type TLBannedCheckPhoneNumberBanned struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=banned.TLConstructor" json:"constructor,omitempty"`
	Phone                string        `protobuf:"bytes,3,opt,name=phone,proto3" json:"phone,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLBannedCheckPhoneNumberBanned) Reset()         { *m = TLBannedCheckPhoneNumberBanned{} }
func (m *TLBannedCheckPhoneNumberBanned) String() string { return proto.CompactTextString(m) }
func (*TLBannedCheckPhoneNumberBanned) ProtoMessage()    {}
func (*TLBannedCheckPhoneNumberBanned) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4d21e2e5430b9c, []int{0}
}
func (m *TLBannedCheckPhoneNumberBanned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLBannedCheckPhoneNumberBanned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLBannedCheckPhoneNumberBanned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLBannedCheckPhoneNumberBanned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLBannedCheckPhoneNumberBanned.Merge(m, src)
}
func (m *TLBannedCheckPhoneNumberBanned) XXX_Size() int {
	return m.Size()
}
func (m *TLBannedCheckPhoneNumberBanned) XXX_DiscardUnknown() {
	xxx_messageInfo_TLBannedCheckPhoneNumberBanned.DiscardUnknown(m)
}

var xxx_messageInfo_TLBannedCheckPhoneNumberBanned proto.InternalMessageInfo

func (m *TLBannedCheckPhoneNumberBanned) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLBannedCheckPhoneNumberBanned) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

//--------------------------------------------------------------------------------------------
// banned.getBannedByPhoneList phones:Vector<string> = Vector<string>;
type TLBannedGetBannedByPhoneList struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=banned.TLConstructor" json:"constructor,omitempty"`
	Phones               []string      `protobuf:"bytes,3,rep,name=phones,proto3" json:"phones,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLBannedGetBannedByPhoneList) Reset()         { *m = TLBannedGetBannedByPhoneList{} }
func (m *TLBannedGetBannedByPhoneList) String() string { return proto.CompactTextString(m) }
func (*TLBannedGetBannedByPhoneList) ProtoMessage()    {}
func (*TLBannedGetBannedByPhoneList) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4d21e2e5430b9c, []int{1}
}
func (m *TLBannedGetBannedByPhoneList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLBannedGetBannedByPhoneList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLBannedGetBannedByPhoneList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLBannedGetBannedByPhoneList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLBannedGetBannedByPhoneList.Merge(m, src)
}
func (m *TLBannedGetBannedByPhoneList) XXX_Size() int {
	return m.Size()
}
func (m *TLBannedGetBannedByPhoneList) XXX_DiscardUnknown() {
	xxx_messageInfo_TLBannedGetBannedByPhoneList.DiscardUnknown(m)
}

var xxx_messageInfo_TLBannedGetBannedByPhoneList proto.InternalMessageInfo

func (m *TLBannedGetBannedByPhoneList) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLBannedGetBannedByPhoneList) GetPhones() []string {
	if m != nil {
		return m.Phones
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// banned.ban phone:string expires:int reason:string = Bool;
type TLBannedBan struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=banned.TLConstructor" json:"constructor,omitempty"`
	Phone                string        `protobuf:"bytes,3,opt,name=phone,proto3" json:"phone,omitempty"`
	Expires              int32         `protobuf:"varint,4,opt,name=expires,proto3" json:"expires,omitempty"`
	Reason               string        `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLBannedBan) Reset()         { *m = TLBannedBan{} }
func (m *TLBannedBan) String() string { return proto.CompactTextString(m) }
func (*TLBannedBan) ProtoMessage()    {}
func (*TLBannedBan) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4d21e2e5430b9c, []int{2}
}
func (m *TLBannedBan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLBannedBan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLBannedBan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLBannedBan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLBannedBan.Merge(m, src)
}
func (m *TLBannedBan) XXX_Size() int {
	return m.Size()
}
func (m *TLBannedBan) XXX_DiscardUnknown() {
	xxx_messageInfo_TLBannedBan.DiscardUnknown(m)
}

var xxx_messageInfo_TLBannedBan proto.InternalMessageInfo

func (m *TLBannedBan) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLBannedBan) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

func (m *TLBannedBan) GetExpires() int32 {
	if m != nil {
		return m.Expires
	}
	return 0
}

func (m *TLBannedBan) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

//--------------------------------------------------------------------------------------------
// banned.unBan phone:string = Bool;
type TLBannedUnBan struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=banned.TLConstructor" json:"constructor,omitempty"`
	Phone                string        `protobuf:"bytes,3,opt,name=phone,proto3" json:"phone,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLBannedUnBan) Reset()         { *m = TLBannedUnBan{} }
func (m *TLBannedUnBan) String() string { return proto.CompactTextString(m) }
func (*TLBannedUnBan) ProtoMessage()    {}
func (*TLBannedUnBan) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4d21e2e5430b9c, []int{3}
}
func (m *TLBannedUnBan) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLBannedUnBan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLBannedUnBan.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLBannedUnBan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLBannedUnBan.Merge(m, src)
}
func (m *TLBannedUnBan) XXX_Size() int {
	return m.Size()
}
func (m *TLBannedUnBan) XXX_DiscardUnknown() {
	xxx_messageInfo_TLBannedUnBan.DiscardUnknown(m)
}

var xxx_messageInfo_TLBannedUnBan proto.InternalMessageInfo

func (m *TLBannedUnBan) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLBannedUnBan) GetPhone() string {
	if m != nil {
		return m.Phone
	}
	return ""
}

//--------------------------------------------------------------------------------------------
// Vector api result type
type Vector_String struct {
	Datas                []string `protobuf:"bytes,1,rep,name=datas,proto3" json:"datas,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Vector_String) Reset()         { *m = Vector_String{} }
func (m *Vector_String) String() string { return proto.CompactTextString(m) }
func (*Vector_String) ProtoMessage()    {}
func (*Vector_String) Descriptor() ([]byte, []int) {
	return fileDescriptor_aa4d21e2e5430b9c, []int{4}
}
func (m *Vector_String) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vector_String) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vector_String.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vector_String) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vector_String.Merge(m, src)
}
func (m *Vector_String) XXX_Size() int {
	return m.Size()
}
func (m *Vector_String) XXX_DiscardUnknown() {
	xxx_messageInfo_Vector_String.DiscardUnknown(m)
}

var xxx_messageInfo_Vector_String proto.InternalMessageInfo

func (m *Vector_String) GetDatas() []string {
	if m != nil {
		return m.Datas
	}
	return nil
}

func init() {
	proto.RegisterEnum("banned.TLConstructor", TLConstructor_name, TLConstructor_value)
	proto.RegisterType((*TLBannedCheckPhoneNumberBanned)(nil), "banned.TL_banned_checkPhoneNumberBanned")
	proto.RegisterType((*TLBannedGetBannedByPhoneList)(nil), "banned.TL_banned_getBannedByPhoneList")
	proto.RegisterType((*TLBannedBan)(nil), "banned.TL_banned_ban")
	proto.RegisterType((*TLBannedUnBan)(nil), "banned.TL_banned_unBan")
	proto.RegisterType((*Vector_String)(nil), "banned.Vector_String")
}

func init() { proto.RegisterFile("banned.tl.proto", fileDescriptor_aa4d21e2e5430b9c) }

var fileDescriptor_aa4d21e2e5430b9c = []byte{
	// 574 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x53, 0xbf, 0x6f, 0xd3, 0x40,
	0x14, 0xce, 0x91, 0xfe, 0x50, 0x0f, 0x42, 0xcd, 0xa9, 0x05, 0x63, 0x84, 0x15, 0x8c, 0x40, 0x11,
	0x52, 0x6d, 0x94, 0x22, 0xc1, 0x4a, 0x32, 0x12, 0x85, 0xca, 0x2d, 0x20, 0x75, 0xc0, 0x9c, 0xdd,
	0xc3, 0xb1, 0x88, 0xef, 0xdc, 0xbb, 0x0b, 0x10, 0xa6, 0x8e, 0x88, 0xa9, 0x23, 0x03, 0x1b, 0x48,
	0xfc, 0x09, 0x8c, 0x20, 0xb1, 0x30, 0x22, 0xb1, 0x30, 0x42, 0xc4, 0x5c, 0xf1, 0x07, 0x20, 0x82,
	0x7c, 0x76, 0xea, 0x44, 0xa9, 0x32, 0xa0, 0x4e, 0x7e, 0xdf, 0xfb, 0xde, 0x7b, 0xdf, 0xbb, 0xf7,
	0x9e, 0xe1, 0xb2, 0x8f, 0x29, 0x25, 0x3b, 0xb6, 0xec, 0xda, 0x09, 0x67, 0x92, 0xa1, 0x85, 0xcc,
	0x61, 0xac, 0x85, 0x91, 0xec, 0xf4, 0x7c, 0x3b, 0x60, 0xb1, 0x13, 0xb2, 0x90, 0x39, 0x8a, 0xf6,
	0x7b, 0x8f, 0x15, 0x52, 0x40, 0x59, 0x59, 0x9a, 0x61, 0x86, 0x8c, 0x85, 0x5d, 0x52, 0x44, 0x3d,
	0xe3, 0x38, 0x49, 0x08, 0x17, 0x39, 0x6f, 0x88, 0xa0, 0x43, 0x62, 0x9c, 0xea, 0x04, 0x8c, 0x13,
	0x4f, 0xf6, 0x13, 0x32, 0xe2, 0xce, 0x17, 0x9c, 0xe4, 0x98, 0x8a, 0x84, 0x71, 0x99, 0x53, 0x2b,
	0x05, 0x25, 0xfa, 0x34, 0xc8, 0xbc, 0xd6, 0x2e, 0xac, 0x6e, 0xb5, 0xbc, 0xac, 0x51, 0x2f, 0xe8,
	0x90, 0xe0, 0xc9, 0x46, 0x87, 0x51, 0xd2, 0xee, 0xc5, 0x3e, 0xe1, 0x0d, 0xe5, 0x46, 0x37, 0xe1,
	0xc9, 0x80, 0x51, 0x21, 0x79, 0x2f, 0x90, 0x8c, 0xeb, 0xa0, 0x0a, 0x6a, 0xa7, 0xeb, 0xab, 0x76,
	0xfe, 0xdc, 0xad, 0x56, 0xb3, 0x20, 0xdd, 0xf1, 0x48, 0xb4, 0x02, 0xe7, 0x93, 0xb4, 0x9a, 0x5e,
	0xae, 0x82, 0xda, 0x92, 0x9b, 0x01, 0x6b, 0x17, 0x9a, 0x85, 0x64, 0x48, 0x64, 0xa6, 0xd2, 0xe8,
	0x2b, 0xe1, 0x56, 0x24, 0xe4, 0xff, 0x0b, 0x9e, 0x85, 0x0b, 0x4a, 0x43, 0xe8, 0xe5, 0x6a, 0xb9,
	0xb6, 0xe4, 0xe6, 0xc8, 0xda, 0x07, 0xb0, 0x52, 0x68, 0xfa, 0x98, 0x1e, 0xf3, 0x9b, 0x90, 0x0e,
	0x17, 0xc9, 0xf3, 0x24, 0xe2, 0x44, 0xe8, 0x73, 0x55, 0x50, 0x9b, 0x77, 0x47, 0x30, 0x6d, 0x89,
	0x13, 0x2c, 0x18, 0xd5, 0xe7, 0x55, 0x42, 0x8e, 0xac, 0x47, 0x70, 0xb9, 0xe8, 0xa8, 0x47, 0x1b,
	0xc7, 0xde, 0x93, 0x75, 0x05, 0x56, 0xee, 0x93, 0x94, 0xf7, 0x36, 0x25, 0x8f, 0x68, 0x98, 0x86,
	0xed, 0x60, 0x89, 0x85, 0x0e, 0xd4, 0x70, 0x32, 0x70, 0xed, 0x93, 0x9a, 0xcd, 0x58, 0x6d, 0x74,
	0x06, 0x56, 0x9a, 0x6e, 0x73, 0xbd, 0xee, 0xdd, 0x6b, 0xdf, 0x69, 0xdf, 0x7d, 0xd0, 0xd6, 0x4a,
	0xe8, 0x3a, 0xbc, 0x9c, 0xb9, 0x66, 0x5e, 0x8a, 0xf6, 0xf9, 0xe3, 0xde, 0xab, 0xbf, 0xc3, 0xe1,
	0x70, 0x08, 0x90, 0x0d, 0x2f, 0x4d, 0x64, 0x1c, 0xb5, 0x68, 0xed, 0xcd, 0xeb, 0x3f, 0xef, 0xf3,
	0x78, 0x1d, 0x6a, 0x13, 0xf1, 0x3e, 0xa6, 0xda, 0xf7, 0x77, 0x07, 0x07, 0x65, 0x64, 0x40, 0x34,
	0xc1, 0xa8, 0x61, 0x69, 0xbf, 0xbe, 0xed, 0xed, 0x2f, 0x1a, 0x73, 0x2f, 0xdf, 0x9a, 0xa5, 0xfa,
	0x87, 0x13, 0x70, 0xc9, 0xdd, 0x68, 0xe6, 0xe7, 0xba, 0x0d, 0x2f, 0xce, 0xbe, 0xe7, 0x5a, 0x31,
	0xd2, 0xd9, 0xef, 0x31, 0x2a, 0x76, 0x2c, 0xd5, 0x7f, 0x62, 0x37, 0x18, 0xeb, 0x5a, 0x25, 0xf4,
	0x10, 0x5e, 0x98, 0x75, 0xb8, 0x57, 0xa7, 0x2b, 0x1f, 0x15, 0x67, 0x1c, 0x2e, 0x75, 0x62, 0x41,
	0x56, 0x09, 0xdd, 0x80, 0x70, 0xec, 0x48, 0x57, 0xa7, 0xcb, 0xf9, 0x98, 0x4e, 0x77, 0x75, 0x0b,
	0x9e, 0x9a, 0x38, 0xa4, 0x73, 0xd3, 0x79, 0x8a, 0x98, 0xca, 0x6c, 0x6c, 0xfe, 0xfe, 0x69, 0x82,
	0x2f, 0x03, 0x13, 0x7c, 0x1d, 0x98, 0xe0, 0xc7, 0xc0, 0x04, 0xdb, 0xb7, 0x25, 0xc1, 0x71, 0xc8,
	0x71, 0x6c, 0x47, 0xcc, 0x19, 0xd9, 0x6b, 0x82, 0xf0, 0xa7, 0x84, 0x3b, 0x38, 0x49, 0x9c, 0xd4,
	0x8c, 0x02, 0xe2, 0xf8, 0xd1, 0x0b, 0xef, 0xd0, 0x56, 0x22, 0xf9, 0xc7, 0x5f, 0x50, 0x12, 0xeb,
	0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0x30, 0x0a, 0x3f, 0x37, 0x11, 0x05, 0x00, 0x00,
}

func (this *TLBannedCheckPhoneNumberBanned) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&banned.TLBannedCheckPhoneNumberBanned{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Phone: "+fmt.Sprintf("%#v", this.Phone)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLBannedGetBannedByPhoneList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&banned.TLBannedGetBannedByPhoneList{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Phones: "+fmt.Sprintf("%#v", this.Phones)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLBannedBan) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&banned.TLBannedBan{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Phone: "+fmt.Sprintf("%#v", this.Phone)+",\n")
	s = append(s, "Expires: "+fmt.Sprintf("%#v", this.Expires)+",\n")
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLBannedUnBan) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&banned.TLBannedUnBan{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Phone: "+fmt.Sprintf("%#v", this.Phone)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Vector_String) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&banned.Vector_String{")
	s = append(s, "Datas: "+fmt.Sprintf("%#v", this.Datas)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringBannedTl(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RPCBannedClient is the client API for RPCBanned service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RPCBannedClient interface {
	// banned.checkPhoneNumberBanned phone:string = Bool;
	BannedCheckPhoneNumberBanned(ctx context.Context, in *TLBannedCheckPhoneNumberBanned, opts ...grpc.CallOption) (*mtproto.Bool, error)
	// banned.getBannedByPhoneList phones:Vector<string> = Vector<string>;
	BannedGetBannedByPhoneList(ctx context.Context, in *TLBannedGetBannedByPhoneList, opts ...grpc.CallOption) (*Vector_String, error)
	// banned.ban phone:string expires:int reason:string = Bool;
	BannedBan(ctx context.Context, in *TLBannedBan, opts ...grpc.CallOption) (*mtproto.Bool, error)
	// banned.unBan phone:string = Bool;
	BannedUnBan(ctx context.Context, in *TLBannedUnBan, opts ...grpc.CallOption) (*mtproto.Bool, error)
}

type rPCBannedClient struct {
	cc *grpc.ClientConn
}

func NewRPCBannedClient(cc *grpc.ClientConn) RPCBannedClient {
	return &rPCBannedClient{cc}
}

func (c *rPCBannedClient) BannedCheckPhoneNumberBanned(ctx context.Context, in *TLBannedCheckPhoneNumberBanned, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/banned.RPCBanned/banned_checkPhoneNumberBanned", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCBannedClient) BannedGetBannedByPhoneList(ctx context.Context, in *TLBannedGetBannedByPhoneList, opts ...grpc.CallOption) (*Vector_String, error) {
	out := new(Vector_String)
	err := c.cc.Invoke(ctx, "/banned.RPCBanned/banned_getBannedByPhoneList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCBannedClient) BannedBan(ctx context.Context, in *TLBannedBan, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/banned.RPCBanned/banned_ban", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCBannedClient) BannedUnBan(ctx context.Context, in *TLBannedUnBan, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/banned.RPCBanned/banned_unBan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RPCBannedServer is the server API for RPCBanned service.
type RPCBannedServer interface {
	// banned.checkPhoneNumberBanned phone:string = Bool;
	BannedCheckPhoneNumberBanned(context.Context, *TLBannedCheckPhoneNumberBanned) (*mtproto.Bool, error)
	// banned.getBannedByPhoneList phones:Vector<string> = Vector<string>;
	BannedGetBannedByPhoneList(context.Context, *TLBannedGetBannedByPhoneList) (*Vector_String, error)
	// banned.ban phone:string expires:int reason:string = Bool;
	BannedBan(context.Context, *TLBannedBan) (*mtproto.Bool, error)
	// banned.unBan phone:string = Bool;
	BannedUnBan(context.Context, *TLBannedUnBan) (*mtproto.Bool, error)
}

// UnimplementedRPCBannedServer can be embedded to have forward compatible implementations.
type UnimplementedRPCBannedServer struct {
}

func (*UnimplementedRPCBannedServer) BannedCheckPhoneNumberBanned(ctx context.Context, req *TLBannedCheckPhoneNumberBanned) (*mtproto.Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BannedCheckPhoneNumberBanned not implemented")
}
func (*UnimplementedRPCBannedServer) BannedGetBannedByPhoneList(ctx context.Context, req *TLBannedGetBannedByPhoneList) (*Vector_String, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BannedGetBannedByPhoneList not implemented")
}
func (*UnimplementedRPCBannedServer) BannedBan(ctx context.Context, req *TLBannedBan) (*mtproto.Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BannedBan not implemented")
}
func (*UnimplementedRPCBannedServer) BannedUnBan(ctx context.Context, req *TLBannedUnBan) (*mtproto.Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BannedUnBan not implemented")
}

func RegisterRPCBannedServer(s *grpc.Server, srv RPCBannedServer) {
	s.RegisterService(&_RPCBanned_serviceDesc, srv)
}

func _RPCBanned_BannedCheckPhoneNumberBanned_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLBannedCheckPhoneNumberBanned)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCBannedServer).BannedCheckPhoneNumberBanned(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/banned.RPCBanned/BannedCheckPhoneNumberBanned",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCBannedServer).BannedCheckPhoneNumberBanned(ctx, req.(*TLBannedCheckPhoneNumberBanned))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCBanned_BannedGetBannedByPhoneList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLBannedGetBannedByPhoneList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCBannedServer).BannedGetBannedByPhoneList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/banned.RPCBanned/BannedGetBannedByPhoneList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCBannedServer).BannedGetBannedByPhoneList(ctx, req.(*TLBannedGetBannedByPhoneList))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCBanned_BannedBan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLBannedBan)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCBannedServer).BannedBan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/banned.RPCBanned/BannedBan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCBannedServer).BannedBan(ctx, req.(*TLBannedBan))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCBanned_BannedUnBan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLBannedUnBan)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCBannedServer).BannedUnBan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/banned.RPCBanned/BannedUnBan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCBannedServer).BannedUnBan(ctx, req.(*TLBannedUnBan))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPCBanned_serviceDesc = grpc.ServiceDesc{
	ServiceName: "banned.RPCBanned",
	HandlerType: (*RPCBannedServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "banned_checkPhoneNumberBanned",
			Handler:    _RPCBanned_BannedCheckPhoneNumberBanned_Handler,
		},
		{
			MethodName: "banned_getBannedByPhoneList",
			Handler:    _RPCBanned_BannedGetBannedByPhoneList_Handler,
		},
		{
			MethodName: "banned_ban",
			Handler:    _RPCBanned_BannedBan_Handler,
		},
		{
			MethodName: "banned_unBan",
			Handler:    _RPCBanned_BannedUnBan_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "banned.tl.proto",
}

func (m *TLBannedCheckPhoneNumberBanned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLBannedCheckPhoneNumberBanned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLBannedCheckPhoneNumberBanned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Phone) > 0 {
		i -= len(m.Phone)
		copy(dAtA[i:], m.Phone)
		i = encodeVarintBannedTl(dAtA, i, uint64(len(m.Phone)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintBannedTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLBannedGetBannedByPhoneList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLBannedGetBannedByPhoneList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLBannedGetBannedByPhoneList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Phones) > 0 {
		for iNdEx := len(m.Phones) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Phones[iNdEx])
			copy(dAtA[i:], m.Phones[iNdEx])
			i = encodeVarintBannedTl(dAtA, i, uint64(len(m.Phones[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Constructor != 0 {
		i = encodeVarintBannedTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLBannedBan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLBannedBan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLBannedBan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintBannedTl(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Expires != 0 {
		i = encodeVarintBannedTl(dAtA, i, uint64(m.Expires))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Phone) > 0 {
		i -= len(m.Phone)
		copy(dAtA[i:], m.Phone)
		i = encodeVarintBannedTl(dAtA, i, uint64(len(m.Phone)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintBannedTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLBannedUnBan) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLBannedUnBan) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLBannedUnBan) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Phone) > 0 {
		i -= len(m.Phone)
		copy(dAtA[i:], m.Phone)
		i = encodeVarintBannedTl(dAtA, i, uint64(len(m.Phone)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintBannedTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Vector_String) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vector_String) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vector_String) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Datas) > 0 {
		for iNdEx := len(m.Datas) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Datas[iNdEx])
			copy(dAtA[i:], m.Datas[iNdEx])
			i = encodeVarintBannedTl(dAtA, i, uint64(len(m.Datas[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintBannedTl(dAtA []byte, offset int, v uint64) int {
	offset -= sovBannedTl(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TLBannedCheckPhoneNumberBanned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovBannedTl(uint64(m.Constructor))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovBannedTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLBannedGetBannedByPhoneList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovBannedTl(uint64(m.Constructor))
	}
	if len(m.Phones) > 0 {
		for _, s := range m.Phones {
			l = len(s)
			n += 1 + l + sovBannedTl(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLBannedBan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovBannedTl(uint64(m.Constructor))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovBannedTl(uint64(l))
	}
	if m.Expires != 0 {
		n += 1 + sovBannedTl(uint64(m.Expires))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovBannedTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLBannedUnBan) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovBannedTl(uint64(m.Constructor))
	}
	l = len(m.Phone)
	if l > 0 {
		n += 1 + l + sovBannedTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Vector_String) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Datas) > 0 {
		for _, s := range m.Datas {
			l = len(s)
			n += 1 + l + sovBannedTl(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovBannedTl(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBannedTl(x uint64) (n int) {
	return sovBannedTl(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TLBannedCheckPhoneNumberBanned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBannedTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_banned_checkPhoneNumberBanned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_banned_checkPhoneNumberBanned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBannedTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBannedTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBannedTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBannedTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBannedTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBannedTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLBannedGetBannedByPhoneList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBannedTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_banned_getBannedByPhoneList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_banned_getBannedByPhoneList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBannedTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phones", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBannedTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBannedTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBannedTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phones = append(m.Phones, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBannedTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBannedTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLBannedBan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBannedTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_banned_ban: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_banned_ban: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBannedTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBannedTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBannedTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBannedTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			m.Expires = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBannedTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expires |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBannedTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBannedTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBannedTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBannedTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBannedTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLBannedUnBan) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBannedTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_banned_unBan: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_banned_unBan: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBannedTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBannedTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBannedTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBannedTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBannedTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBannedTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vector_String) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBannedTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vector_String: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vector_String: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datas", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBannedTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBannedTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBannedTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datas = append(m.Datas, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBannedTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBannedTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBannedTl(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBannedTl
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBannedTl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBannedTl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBannedTl
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBannedTl
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBannedTl
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBannedTl        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBannedTl          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBannedTl = fmt.Errorf("proto: unexpected end of group")
)
