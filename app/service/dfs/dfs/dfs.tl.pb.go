// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dfs.tl.proto

package dfs

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	mtproto "github.com/teamgram/proto/mtproto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TLConstructor int32

const (
	CRC32_UNKNOWN                      TLConstructor = 0
	CRC32_dfs_writeFilePartData        TLConstructor = 440942855
	CRC32_dfs_uploadPhotoFileV2        TLConstructor = 605082018
	CRC32_dfs_uploadProfilePhotoFileV2 TLConstructor = -870473038
	CRC32_dfs_uploadEncryptedFileV2    TLConstructor = 2043921699
	CRC32_dfs_downloadFile             TLConstructor = -2144148946
	CRC32_dfs_uploadDocumentFileV2     TLConstructor = 1983081911
	CRC32_dfs_uploadGifDocumentMedia   TLConstructor = 1103416576
	CRC32_dfs_uploadMp4DocumentMedia   TLConstructor = -1566246888
	CRC32_dfs_uploadWallPaperFile      TLConstructor = -1046081450
	CRC32_dfs_uploadThemeFile          TLConstructor = -559525993
)

var TLConstructor_name = map[int32]string{
	0:           "CRC32_UNKNOWN",
	440942855:   "CRC32_dfs_writeFilePartData",
	605082018:   "CRC32_dfs_uploadPhotoFileV2",
	-870473038:  "CRC32_dfs_uploadProfilePhotoFileV2",
	2043921699:  "CRC32_dfs_uploadEncryptedFileV2",
	-2144148946: "CRC32_dfs_downloadFile",
	1983081911:  "CRC32_dfs_uploadDocumentFileV2",
	1103416576:  "CRC32_dfs_uploadGifDocumentMedia",
	-1566246888: "CRC32_dfs_uploadMp4DocumentMedia",
	-1046081450: "CRC32_dfs_uploadWallPaperFile",
	-559525993:  "CRC32_dfs_uploadThemeFile",
}

var TLConstructor_value = map[string]int32{
	"CRC32_UNKNOWN":                      0,
	"CRC32_dfs_writeFilePartData":        440942855,
	"CRC32_dfs_uploadPhotoFileV2":        605082018,
	"CRC32_dfs_uploadProfilePhotoFileV2": -870473038,
	"CRC32_dfs_uploadEncryptedFileV2":    2043921699,
	"CRC32_dfs_downloadFile":             -2144148946,
	"CRC32_dfs_uploadDocumentFileV2":     1983081911,
	"CRC32_dfs_uploadGifDocumentMedia":   1103416576,
	"CRC32_dfs_uploadMp4DocumentMedia":   -1566246888,
	"CRC32_dfs_uploadWallPaperFile":      -1046081450,
	"CRC32_dfs_uploadThemeFile":          -559525993,
}

func (x TLConstructor) String() string {
	return proto.EnumName(TLConstructor_name, int32(x))
}

func (TLConstructor) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1c9cc97391f90775, []int{0}
}

//--------------------------------------------------------------------------------------------
// dfs.writeFilePartData flags:# creator:long file_id:long file_part:int bytes:bytes big:flags.0?true file_total_parts:flags.1?int = Bool;
type TLDfsWriteFilePartData struct {
	Constructor          TLConstructor     `protobuf:"varint,1,opt,name=constructor,proto3,enum=dfs.TLConstructor" json:"constructor,omitempty"`
	Creator              int64             `protobuf:"varint,3,opt,name=creator,proto3" json:"creator,omitempty"`
	FileId               int64             `protobuf:"varint,4,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	FilePart             int32             `protobuf:"varint,5,opt,name=file_part,json=filePart,proto3" json:"file_part,omitempty"`
	Bytes                []byte            `protobuf:"bytes,6,opt,name=bytes,proto3" json:"bytes,omitempty"`
	Big                  bool              `protobuf:"varint,7,opt,name=big,proto3" json:"big,omitempty"`
	FileTotalParts       *types.Int32Value `protobuf:"bytes,8,opt,name=file_total_parts,json=fileTotalParts,proto3" json:"file_total_parts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TLDfsWriteFilePartData) Reset()         { *m = TLDfsWriteFilePartData{} }
func (m *TLDfsWriteFilePartData) String() string { return proto.CompactTextString(m) }
func (*TLDfsWriteFilePartData) ProtoMessage()    {}
func (*TLDfsWriteFilePartData) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c9cc97391f90775, []int{0}
}
func (m *TLDfsWriteFilePartData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLDfsWriteFilePartData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLDfsWriteFilePartData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLDfsWriteFilePartData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLDfsWriteFilePartData.Merge(m, src)
}
func (m *TLDfsWriteFilePartData) XXX_Size() int {
	return m.Size()
}
func (m *TLDfsWriteFilePartData) XXX_DiscardUnknown() {
	xxx_messageInfo_TLDfsWriteFilePartData.DiscardUnknown(m)
}

var xxx_messageInfo_TLDfsWriteFilePartData proto.InternalMessageInfo

func (m *TLDfsWriteFilePartData) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLDfsWriteFilePartData) GetCreator() int64 {
	if m != nil {
		return m.Creator
	}
	return 0
}

func (m *TLDfsWriteFilePartData) GetFileId() int64 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *TLDfsWriteFilePartData) GetFilePart() int32 {
	if m != nil {
		return m.FilePart
	}
	return 0
}

func (m *TLDfsWriteFilePartData) GetBytes() []byte {
	if m != nil {
		return m.Bytes
	}
	return nil
}

func (m *TLDfsWriteFilePartData) GetBig() bool {
	if m != nil {
		return m.Big
	}
	return false
}

func (m *TLDfsWriteFilePartData) GetFileTotalParts() *types.Int32Value {
	if m != nil {
		return m.FileTotalParts
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// dfs.uploadPhotoFileV2 creator:long file:InputFile = Photo;
type TLDfsUploadPhotoFileV2 struct {
	Constructor          TLConstructor      `protobuf:"varint,1,opt,name=constructor,proto3,enum=dfs.TLConstructor" json:"constructor,omitempty"`
	Creator              int64              `protobuf:"varint,3,opt,name=creator,proto3" json:"creator,omitempty"`
	File                 *mtproto.InputFile `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TLDfsUploadPhotoFileV2) Reset()         { *m = TLDfsUploadPhotoFileV2{} }
func (m *TLDfsUploadPhotoFileV2) String() string { return proto.CompactTextString(m) }
func (*TLDfsUploadPhotoFileV2) ProtoMessage()    {}
func (*TLDfsUploadPhotoFileV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c9cc97391f90775, []int{1}
}
func (m *TLDfsUploadPhotoFileV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLDfsUploadPhotoFileV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLDfsUploadPhotoFileV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLDfsUploadPhotoFileV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLDfsUploadPhotoFileV2.Merge(m, src)
}
func (m *TLDfsUploadPhotoFileV2) XXX_Size() int {
	return m.Size()
}
func (m *TLDfsUploadPhotoFileV2) XXX_DiscardUnknown() {
	xxx_messageInfo_TLDfsUploadPhotoFileV2.DiscardUnknown(m)
}

var xxx_messageInfo_TLDfsUploadPhotoFileV2 proto.InternalMessageInfo

func (m *TLDfsUploadPhotoFileV2) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLDfsUploadPhotoFileV2) GetCreator() int64 {
	if m != nil {
		return m.Creator
	}
	return 0
}

func (m *TLDfsUploadPhotoFileV2) GetFile() *mtproto.InputFile {
	if m != nil {
		return m.File
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// dfs.uploadProfilePhotoFileV2 flags:# creator:long file:flags.0?InputFile video:flags.1?InputFile video_start_ts:flags.2?double = Photo;
type TLDfsUploadProfilePhotoFileV2 struct {
	Constructor          TLConstructor      `protobuf:"varint,1,opt,name=constructor,proto3,enum=dfs.TLConstructor" json:"constructor,omitempty"`
	Creator              int64              `protobuf:"varint,3,opt,name=creator,proto3" json:"creator,omitempty"`
	File                 *mtproto.InputFile `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	Video                *mtproto.InputFile `protobuf:"bytes,5,opt,name=video,proto3" json:"video,omitempty"`
	VideoStartTs         *types.DoubleValue `protobuf:"bytes,6,opt,name=video_start_ts,json=videoStartTs,proto3" json:"video_start_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TLDfsUploadProfilePhotoFileV2) Reset()         { *m = TLDfsUploadProfilePhotoFileV2{} }
func (m *TLDfsUploadProfilePhotoFileV2) String() string { return proto.CompactTextString(m) }
func (*TLDfsUploadProfilePhotoFileV2) ProtoMessage()    {}
func (*TLDfsUploadProfilePhotoFileV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c9cc97391f90775, []int{2}
}
func (m *TLDfsUploadProfilePhotoFileV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLDfsUploadProfilePhotoFileV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLDfsUploadProfilePhotoFileV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLDfsUploadProfilePhotoFileV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLDfsUploadProfilePhotoFileV2.Merge(m, src)
}
func (m *TLDfsUploadProfilePhotoFileV2) XXX_Size() int {
	return m.Size()
}
func (m *TLDfsUploadProfilePhotoFileV2) XXX_DiscardUnknown() {
	xxx_messageInfo_TLDfsUploadProfilePhotoFileV2.DiscardUnknown(m)
}

var xxx_messageInfo_TLDfsUploadProfilePhotoFileV2 proto.InternalMessageInfo

func (m *TLDfsUploadProfilePhotoFileV2) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLDfsUploadProfilePhotoFileV2) GetCreator() int64 {
	if m != nil {
		return m.Creator
	}
	return 0
}

func (m *TLDfsUploadProfilePhotoFileV2) GetFile() *mtproto.InputFile {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *TLDfsUploadProfilePhotoFileV2) GetVideo() *mtproto.InputFile {
	if m != nil {
		return m.Video
	}
	return nil
}

func (m *TLDfsUploadProfilePhotoFileV2) GetVideoStartTs() *types.DoubleValue {
	if m != nil {
		return m.VideoStartTs
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// dfs.uploadEncryptedFileV2 creator:long file:InputEncryptedFile = EncryptedFile;
type TLDfsUploadEncryptedFileV2 struct {
	Constructor          TLConstructor               `protobuf:"varint,1,opt,name=constructor,proto3,enum=dfs.TLConstructor" json:"constructor,omitempty"`
	Creator              int64                       `protobuf:"varint,3,opt,name=creator,proto3" json:"creator,omitempty"`
	File                 *mtproto.InputEncryptedFile `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *TLDfsUploadEncryptedFileV2) Reset()         { *m = TLDfsUploadEncryptedFileV2{} }
func (m *TLDfsUploadEncryptedFileV2) String() string { return proto.CompactTextString(m) }
func (*TLDfsUploadEncryptedFileV2) ProtoMessage()    {}
func (*TLDfsUploadEncryptedFileV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c9cc97391f90775, []int{3}
}
func (m *TLDfsUploadEncryptedFileV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLDfsUploadEncryptedFileV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLDfsUploadEncryptedFileV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLDfsUploadEncryptedFileV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLDfsUploadEncryptedFileV2.Merge(m, src)
}
func (m *TLDfsUploadEncryptedFileV2) XXX_Size() int {
	return m.Size()
}
func (m *TLDfsUploadEncryptedFileV2) XXX_DiscardUnknown() {
	xxx_messageInfo_TLDfsUploadEncryptedFileV2.DiscardUnknown(m)
}

var xxx_messageInfo_TLDfsUploadEncryptedFileV2 proto.InternalMessageInfo

func (m *TLDfsUploadEncryptedFileV2) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLDfsUploadEncryptedFileV2) GetCreator() int64 {
	if m != nil {
		return m.Creator
	}
	return 0
}

func (m *TLDfsUploadEncryptedFileV2) GetFile() *mtproto.InputEncryptedFile {
	if m != nil {
		return m.File
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// dfs.downloadFile location:InputFileLocation offset:int limit:int = upload.File;
type TLDfsDownloadFile struct {
	Constructor          TLConstructor              `protobuf:"varint,1,opt,name=constructor,proto3,enum=dfs.TLConstructor" json:"constructor,omitempty"`
	Location             *mtproto.InputFileLocation `protobuf:"bytes,3,opt,name=location,proto3" json:"location,omitempty"`
	Offset               int32                      `protobuf:"varint,4,opt,name=offset,proto3" json:"offset,omitempty"`
	Limit                int32                      `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *TLDfsDownloadFile) Reset()         { *m = TLDfsDownloadFile{} }
func (m *TLDfsDownloadFile) String() string { return proto.CompactTextString(m) }
func (*TLDfsDownloadFile) ProtoMessage()    {}
func (*TLDfsDownloadFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c9cc97391f90775, []int{4}
}
func (m *TLDfsDownloadFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLDfsDownloadFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLDfsDownloadFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLDfsDownloadFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLDfsDownloadFile.Merge(m, src)
}
func (m *TLDfsDownloadFile) XXX_Size() int {
	return m.Size()
}
func (m *TLDfsDownloadFile) XXX_DiscardUnknown() {
	xxx_messageInfo_TLDfsDownloadFile.DiscardUnknown(m)
}

var xxx_messageInfo_TLDfsDownloadFile proto.InternalMessageInfo

func (m *TLDfsDownloadFile) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLDfsDownloadFile) GetLocation() *mtproto.InputFileLocation {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *TLDfsDownloadFile) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *TLDfsDownloadFile) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// dfs.uploadDocumentFileV2 creator:long media:InputMedia = Document;
type TLDfsUploadDocumentFileV2 struct {
	Constructor          TLConstructor       `protobuf:"varint,1,opt,name=constructor,proto3,enum=dfs.TLConstructor" json:"constructor,omitempty"`
	Creator              int64               `protobuf:"varint,3,opt,name=creator,proto3" json:"creator,omitempty"`
	Media                *mtproto.InputMedia `protobuf:"bytes,4,opt,name=media,proto3" json:"media,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TLDfsUploadDocumentFileV2) Reset()         { *m = TLDfsUploadDocumentFileV2{} }
func (m *TLDfsUploadDocumentFileV2) String() string { return proto.CompactTextString(m) }
func (*TLDfsUploadDocumentFileV2) ProtoMessage()    {}
func (*TLDfsUploadDocumentFileV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c9cc97391f90775, []int{5}
}
func (m *TLDfsUploadDocumentFileV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLDfsUploadDocumentFileV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLDfsUploadDocumentFileV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLDfsUploadDocumentFileV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLDfsUploadDocumentFileV2.Merge(m, src)
}
func (m *TLDfsUploadDocumentFileV2) XXX_Size() int {
	return m.Size()
}
func (m *TLDfsUploadDocumentFileV2) XXX_DiscardUnknown() {
	xxx_messageInfo_TLDfsUploadDocumentFileV2.DiscardUnknown(m)
}

var xxx_messageInfo_TLDfsUploadDocumentFileV2 proto.InternalMessageInfo

func (m *TLDfsUploadDocumentFileV2) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLDfsUploadDocumentFileV2) GetCreator() int64 {
	if m != nil {
		return m.Creator
	}
	return 0
}

func (m *TLDfsUploadDocumentFileV2) GetMedia() *mtproto.InputMedia {
	if m != nil {
		return m.Media
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// dfs.uploadGifDocumentMedia creator:long media:InputMedia = Document;
type TLDfsUploadGifDocumentMedia struct {
	Constructor          TLConstructor       `protobuf:"varint,1,opt,name=constructor,proto3,enum=dfs.TLConstructor" json:"constructor,omitempty"`
	Creator              int64               `protobuf:"varint,3,opt,name=creator,proto3" json:"creator,omitempty"`
	Media                *mtproto.InputMedia `protobuf:"bytes,4,opt,name=media,proto3" json:"media,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TLDfsUploadGifDocumentMedia) Reset()         { *m = TLDfsUploadGifDocumentMedia{} }
func (m *TLDfsUploadGifDocumentMedia) String() string { return proto.CompactTextString(m) }
func (*TLDfsUploadGifDocumentMedia) ProtoMessage()    {}
func (*TLDfsUploadGifDocumentMedia) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c9cc97391f90775, []int{6}
}
func (m *TLDfsUploadGifDocumentMedia) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLDfsUploadGifDocumentMedia) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLDfsUploadGifDocumentMedia.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLDfsUploadGifDocumentMedia) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLDfsUploadGifDocumentMedia.Merge(m, src)
}
func (m *TLDfsUploadGifDocumentMedia) XXX_Size() int {
	return m.Size()
}
func (m *TLDfsUploadGifDocumentMedia) XXX_DiscardUnknown() {
	xxx_messageInfo_TLDfsUploadGifDocumentMedia.DiscardUnknown(m)
}

var xxx_messageInfo_TLDfsUploadGifDocumentMedia proto.InternalMessageInfo

func (m *TLDfsUploadGifDocumentMedia) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLDfsUploadGifDocumentMedia) GetCreator() int64 {
	if m != nil {
		return m.Creator
	}
	return 0
}

func (m *TLDfsUploadGifDocumentMedia) GetMedia() *mtproto.InputMedia {
	if m != nil {
		return m.Media
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// dfs.uploadMp4DocumentMedia creator:long media:InputMedia = Document;
type TLDfsUploadMp4DocumentMedia struct {
	Constructor          TLConstructor       `protobuf:"varint,1,opt,name=constructor,proto3,enum=dfs.TLConstructor" json:"constructor,omitempty"`
	Creator              int64               `protobuf:"varint,3,opt,name=creator,proto3" json:"creator,omitempty"`
	Media                *mtproto.InputMedia `protobuf:"bytes,4,opt,name=media,proto3" json:"media,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TLDfsUploadMp4DocumentMedia) Reset()         { *m = TLDfsUploadMp4DocumentMedia{} }
func (m *TLDfsUploadMp4DocumentMedia) String() string { return proto.CompactTextString(m) }
func (*TLDfsUploadMp4DocumentMedia) ProtoMessage()    {}
func (*TLDfsUploadMp4DocumentMedia) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c9cc97391f90775, []int{7}
}
func (m *TLDfsUploadMp4DocumentMedia) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLDfsUploadMp4DocumentMedia) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLDfsUploadMp4DocumentMedia.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLDfsUploadMp4DocumentMedia) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLDfsUploadMp4DocumentMedia.Merge(m, src)
}
func (m *TLDfsUploadMp4DocumentMedia) XXX_Size() int {
	return m.Size()
}
func (m *TLDfsUploadMp4DocumentMedia) XXX_DiscardUnknown() {
	xxx_messageInfo_TLDfsUploadMp4DocumentMedia.DiscardUnknown(m)
}

var xxx_messageInfo_TLDfsUploadMp4DocumentMedia proto.InternalMessageInfo

func (m *TLDfsUploadMp4DocumentMedia) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLDfsUploadMp4DocumentMedia) GetCreator() int64 {
	if m != nil {
		return m.Creator
	}
	return 0
}

func (m *TLDfsUploadMp4DocumentMedia) GetMedia() *mtproto.InputMedia {
	if m != nil {
		return m.Media
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// dfs.uploadWallPaperFile creator:long file:InputFile mime_type:string admin:Bool = Document;
type TLDfsUploadWallPaperFile struct {
	Constructor          TLConstructor      `protobuf:"varint,1,opt,name=constructor,proto3,enum=dfs.TLConstructor" json:"constructor,omitempty"`
	Creator              int64              `protobuf:"varint,3,opt,name=creator,proto3" json:"creator,omitempty"`
	File                 *mtproto.InputFile `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	MimeType             string             `protobuf:"bytes,5,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	Admin                *mtproto.Bool      `protobuf:"bytes,6,opt,name=admin,proto3" json:"admin,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TLDfsUploadWallPaperFile) Reset()         { *m = TLDfsUploadWallPaperFile{} }
func (m *TLDfsUploadWallPaperFile) String() string { return proto.CompactTextString(m) }
func (*TLDfsUploadWallPaperFile) ProtoMessage()    {}
func (*TLDfsUploadWallPaperFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c9cc97391f90775, []int{8}
}
func (m *TLDfsUploadWallPaperFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLDfsUploadWallPaperFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLDfsUploadWallPaperFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLDfsUploadWallPaperFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLDfsUploadWallPaperFile.Merge(m, src)
}
func (m *TLDfsUploadWallPaperFile) XXX_Size() int {
	return m.Size()
}
func (m *TLDfsUploadWallPaperFile) XXX_DiscardUnknown() {
	xxx_messageInfo_TLDfsUploadWallPaperFile.DiscardUnknown(m)
}

var xxx_messageInfo_TLDfsUploadWallPaperFile proto.InternalMessageInfo

func (m *TLDfsUploadWallPaperFile) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLDfsUploadWallPaperFile) GetCreator() int64 {
	if m != nil {
		return m.Creator
	}
	return 0
}

func (m *TLDfsUploadWallPaperFile) GetFile() *mtproto.InputFile {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *TLDfsUploadWallPaperFile) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *TLDfsUploadWallPaperFile) GetAdmin() *mtproto.Bool {
	if m != nil {
		return m.Admin
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// dfs.uploadThemeFile flags:# creator:long file:InputFile thumb:flags.0?InputFile mime_type:string file_name:string = Document;
type TLDfsUploadThemeFile struct {
	Constructor          TLConstructor      `protobuf:"varint,1,opt,name=constructor,proto3,enum=dfs.TLConstructor" json:"constructor,omitempty"`
	Creator              int64              `protobuf:"varint,3,opt,name=creator,proto3" json:"creator,omitempty"`
	File                 *mtproto.InputFile `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	Thumb                *mtproto.InputFile `protobuf:"bytes,5,opt,name=thumb,proto3" json:"thumb,omitempty"`
	MimeType             string             `protobuf:"bytes,6,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	FileName             string             `protobuf:"bytes,7,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TLDfsUploadThemeFile) Reset()         { *m = TLDfsUploadThemeFile{} }
func (m *TLDfsUploadThemeFile) String() string { return proto.CompactTextString(m) }
func (*TLDfsUploadThemeFile) ProtoMessage()    {}
func (*TLDfsUploadThemeFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_1c9cc97391f90775, []int{9}
}
func (m *TLDfsUploadThemeFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLDfsUploadThemeFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLDfsUploadThemeFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLDfsUploadThemeFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLDfsUploadThemeFile.Merge(m, src)
}
func (m *TLDfsUploadThemeFile) XXX_Size() int {
	return m.Size()
}
func (m *TLDfsUploadThemeFile) XXX_DiscardUnknown() {
	xxx_messageInfo_TLDfsUploadThemeFile.DiscardUnknown(m)
}

var xxx_messageInfo_TLDfsUploadThemeFile proto.InternalMessageInfo

func (m *TLDfsUploadThemeFile) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLDfsUploadThemeFile) GetCreator() int64 {
	if m != nil {
		return m.Creator
	}
	return 0
}

func (m *TLDfsUploadThemeFile) GetFile() *mtproto.InputFile {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *TLDfsUploadThemeFile) GetThumb() *mtproto.InputFile {
	if m != nil {
		return m.Thumb
	}
	return nil
}

func (m *TLDfsUploadThemeFile) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *TLDfsUploadThemeFile) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func init() {
	proto.RegisterEnum("dfs.TLConstructor", TLConstructor_name, TLConstructor_value)
	proto.RegisterType((*TLDfsWriteFilePartData)(nil), "dfs.TL_dfs_writeFilePartData")
	proto.RegisterType((*TLDfsUploadPhotoFileV2)(nil), "dfs.TL_dfs_uploadPhotoFileV2")
	proto.RegisterType((*TLDfsUploadProfilePhotoFileV2)(nil), "dfs.TL_dfs_uploadProfilePhotoFileV2")
	proto.RegisterType((*TLDfsUploadEncryptedFileV2)(nil), "dfs.TL_dfs_uploadEncryptedFileV2")
	proto.RegisterType((*TLDfsDownloadFile)(nil), "dfs.TL_dfs_downloadFile")
	proto.RegisterType((*TLDfsUploadDocumentFileV2)(nil), "dfs.TL_dfs_uploadDocumentFileV2")
	proto.RegisterType((*TLDfsUploadGifDocumentMedia)(nil), "dfs.TL_dfs_uploadGifDocumentMedia")
	proto.RegisterType((*TLDfsUploadMp4DocumentMedia)(nil), "dfs.TL_dfs_uploadMp4DocumentMedia")
	proto.RegisterType((*TLDfsUploadWallPaperFile)(nil), "dfs.TL_dfs_uploadWallPaperFile")
	proto.RegisterType((*TLDfsUploadThemeFile)(nil), "dfs.TL_dfs_uploadThemeFile")
}

func init() { proto.RegisterFile("dfs.tl.proto", fileDescriptor_1c9cc97391f90775) }

var fileDescriptor_1c9cc97391f90775 = []byte{
	// 1098 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0xcd, 0x6f, 0xdc, 0xc4,
	0x1b, 0x5e, 0x27, 0xd9, 0x4d, 0xf2, 0xe6, 0x43, 0xee, 0x24, 0xbf, 0x74, 0xe3, 0x4d, 0x36, 0xfb,
	0x73, 0x50, 0x59, 0x2a, 0x65, 0x57, 0xda, 0x54, 0xdc, 0x49, 0x52, 0x42, 0x44, 0x9a, 0x06, 0xb3,
	0x4d, 0x11, 0x97, 0xd5, 0xac, 0x3d, 0xde, 0x58, 0xb2, 0x3d, 0x96, 0x3d, 0xdb, 0x28, 0x37, 0xe0,
	0x52, 0x84, 0x04, 0x48, 0x54, 0x88, 0xd0, 0x4b, 0x0b, 0xb9, 0x57, 0x2a, 0x17, 0xfe, 0x00, 0x3e,
	0x84, 0x84, 0xf8, 0x10, 0x87, 0x5e, 0xb8, 0x94, 0xfc, 0x05, 0x3d, 0x00, 0x42, 0xa8, 0x28, 0xc8,
	0x63, 0xaf, 0x13, 0x7f, 0x24, 0x42, 0x94, 0xaa, 0x3d, 0xac, 0x34, 0xe3, 0xe7, 0x99, 0x67, 0x9e,
	0xf7, 0x9d, 0x99, 0xf7, 0x5d, 0x18, 0xd5, 0x74, 0xaf, 0xc6, 0xcc, 0x9a, 0xe3, 0x52, 0x46, 0x51,
	0xbf, 0xa6, 0x7b, 0xd2, 0x42, 0xc7, 0x60, 0xdb, 0xdd, 0x76, 0x4d, 0xa5, 0x56, 0xbd, 0x43, 0x3b,
	0xb4, 0xce, 0xb1, 0x76, 0x57, 0xe7, 0x33, 0x3e, 0xe1, 0xa3, 0x60, 0x8d, 0x54, 0xee, 0x50, 0xda,
	0x31, 0xc9, 0x11, 0x6b, 0xc7, 0xc5, 0x8e, 0x43, 0x5c, 0x2f, 0xc4, 0x25, 0x4f, 0xdd, 0x26, 0x16,
	0xf6, 0x37, 0x51, 0xa9, 0x4b, 0x5a, 0x6c, 0xd7, 0x21, 0x3d, 0x6c, 0xfa, 0x08, 0x63, 0x2e, 0xb6,
	0x3d, 0x87, 0xba, 0x2c, 0x84, 0x26, 0x8f, 0x20, 0x6f, 0xd7, 0x56, 0x83, 0xaf, 0xf2, 0xfb, 0x7d,
	0x50, 0x6c, 0xae, 0xb7, 0x34, 0xdd, 0x6b, 0xed, 0xb8, 0x06, 0x23, 0x2f, 0x1a, 0x26, 0xd9, 0xc4,
	0x2e, 0x5b, 0xc1, 0x0c, 0xa3, 0x0b, 0x30, 0xa2, 0x52, 0xdb, 0x63, 0x6e, 0x57, 0x65, 0xd4, 0x2d,
	0x0a, 0x15, 0xa1, 0x3a, 0xde, 0x40, 0x35, 0x3f, 0xc2, 0xe6, 0xfa, 0xf2, 0x11, 0xa2, 0x1c, 0xa7,
	0xa1, 0x22, 0x0c, 0xaa, 0x2e, 0xc1, 0xfe, 0x8a, 0xfe, 0x8a, 0x50, 0xed, 0x57, 0x7a, 0x53, 0x74,
	0x16, 0x06, 0x75, 0xc3, 0x24, 0x2d, 0x43, 0x2b, 0x0e, 0x70, 0xa4, 0xe0, 0x4f, 0xd7, 0x34, 0x54,
	0x82, 0x61, 0x0e, 0x38, 0xd8, 0x65, 0xc5, 0x7c, 0x45, 0xa8, 0xe6, 0x95, 0x21, 0x3d, 0x74, 0x82,
	0x26, 0x21, 0xdf, 0xde, 0x65, 0xc4, 0x2b, 0x16, 0x2a, 0x42, 0x75, 0x54, 0x09, 0x26, 0x48, 0x84,
	0xfe, 0xb6, 0xd1, 0x29, 0x0e, 0x56, 0x84, 0xea, 0x90, 0xe2, 0x0f, 0xd1, 0x45, 0x10, 0xb9, 0x08,
	0xa3, 0x0c, 0x9b, 0x5c, 0xca, 0x2b, 0x0e, 0x55, 0x84, 0xea, 0x48, 0xa3, 0x54, 0x0b, 0x52, 0x5a,
	0xeb, 0xa5, 0xb4, 0xb6, 0x66, 0xb3, 0xc5, 0xc6, 0x16, 0x36, 0xbb, 0x44, 0x19, 0xf7, 0x17, 0x35,
	0xfd, 0x35, 0xfe, 0x6e, 0x9e, 0xfc, 0x81, 0x10, 0x65, 0xa4, 0xeb, 0x98, 0x14, 0x6b, 0x9b, 0xdb,
	0x94, 0x51, 0x3f, 0x2f, 0x5b, 0x8d, 0xff, 0x3c, 0x23, 0xe7, 0x60, 0xc0, 0xdf, 0x9e, 0xa7, 0x63,
	0xa4, 0x81, 0x6a, 0x16, 0xe3, 0x16, 0x6b, 0x6b, 0xb6, 0xd3, 0x65, 0xfe, 0x9e, 0x0a, 0xc7, 0xe5,
	0xeb, 0x7d, 0x30, 0x17, 0x37, 0xe5, 0x52, 0x9e, 0xa0, 0x27, 0xef, 0x0d, 0x55, 0x21, 0x7f, 0xcd,
	0xd0, 0x08, 0xe5, 0x07, 0x97, 0x4d, 0x0c, 0x08, 0x68, 0x09, 0xc6, 0xf9, 0xa0, 0xe5, 0x31, 0xec,
	0xb2, 0x16, 0x0b, 0x8e, 0x74, 0xa4, 0x31, 0x93, 0x3a, 0x9f, 0x15, 0xda, 0x6d, 0x9b, 0x24, 0x38,
	0xa0, 0x51, 0xbe, 0xe6, 0x55, 0x7f, 0x49, 0xd3, 0x93, 0x6f, 0x09, 0x30, 0x13, 0xcb, 0xc4, 0x45,
	0x5b, 0x75, 0x77, 0x1d, 0x46, 0xb4, 0xc7, 0x94, 0x86, 0x7a, 0x2c, 0x0d, 0xa5, 0x78, 0x74, 0xb1,
	0xcd, 0xc3, 0xb3, 0xba, 0x2b, 0xc0, 0x44, 0xe8, 0x50, 0xa3, 0x3b, 0xb6, 0xef, 0xd1, 0x47, 0xff,
	0xa5, 0xb1, 0xe7, 0x61, 0xc8, 0xa4, 0x2a, 0x66, 0x06, 0xb5, 0xb9, 0xb3, 0x91, 0x86, 0x94, 0x4e,
	0xf0, 0x7a, 0xc8, 0x50, 0x22, 0x2e, 0x9a, 0x82, 0x02, 0xd5, 0x75, 0x8f, 0x30, 0x6e, 0x3c, 0xaf,
	0x84, 0x33, 0xff, 0x35, 0x99, 0x86, 0x65, 0xf4, 0x9e, 0x59, 0x30, 0x91, 0xf7, 0x04, 0x28, 0xc5,
	0xb2, 0xba, 0x42, 0xd5, 0xae, 0x45, 0x6c, 0xf6, 0x98, 0x92, 0xfa, 0x1c, 0xe4, 0x2d, 0xa2, 0x19,
	0x38, 0xcc, 0xea, 0x44, 0x3c, 0xa4, 0x4b, 0x3e, 0xa4, 0x04, 0x0c, 0xf9, 0xa6, 0x00, 0xb3, 0x31,
	0x6b, 0xab, 0x86, 0xde, 0x73, 0xc7, 0x89, 0x4f, 0x95, 0xb9, 0x4b, 0xce, 0x85, 0xa7, 0xc6, 0xdc,
	0x3d, 0x01, 0xa4, 0x98, 0xb9, 0xab, 0xd8, 0x34, 0x37, 0xb1, 0x43, 0xdc, 0x47, 0xb8, 0x8f, 0x8f,
	0x5e, 0x2f, 0x4a, 0x30, 0x6c, 0x19, 0x56, 0xd0, 0xb7, 0xf8, 0x2d, 0x1c, 0x56, 0x86, 0xfc, 0x0f,
	0xcd, 0x5d, 0x87, 0xa0, 0x79, 0xc8, 0x63, 0xcd, 0x32, 0xec, 0xb0, 0x32, 0x8c, 0x45, 0x2a, 0x4b,
	0x94, 0x9a, 0x4a, 0x80, 0xc9, 0xbf, 0x0a, 0x30, 0x15, 0x0b, 0xac, 0xb9, 0x4d, 0x2c, 0xf2, 0x44,
	0x83, 0xaa, 0x42, 0x9e, 0x6d, 0x77, 0xad, 0xf6, 0x69, 0x45, 0x90, 0x13, 0xe2, 0xe1, 0x17, 0x12,
	0xe1, 0xf7, 0x1a, 0xa1, 0x8d, 0x2d, 0xc2, 0x7b, 0xdb, 0x70, 0xd0, 0x08, 0x37, 0xb0, 0x45, 0xce,
	0x7f, 0xdd, 0x0f, 0x63, 0xb1, 0x20, 0xd0, 0x19, 0x18, 0x5b, 0x56, 0x96, 0x17, 0x1b, 0xad, 0x2b,
	0x1b, 0x2f, 0x6f, 0x5c, 0xbe, 0xba, 0x21, 0xe6, 0xd0, 0x3c, 0x94, 0x82, 0x4f, 0x99, 0x2d, 0x5d,
	0xbc, 0xfe, 0xd6, 0x27, 0x3f, 0x09, 0x71, 0x52, 0xaa, 0xcb, 0x89, 0x9f, 0xee, 0x7f, 0x71, 0xbb,
	0x0f, 0xd5, 0x41, 0x4e, 0x91, 0x52, 0x5d, 0x47, 0xfc, 0xec, 0xab, 0xdf, 0xef, 0x3f, 0x3c, 0x3c,
	0x3c, 0x3c, 0x14, 0xd0, 0xb3, 0x30, 0x97, 0x5c, 0x90, 0x28, 0xce, 0xe2, 0xfe, 0x3b, 0x3f, 0x7c,
	0x3f, 0x88, 0xe6, 0x61, 0xea, 0x88, 0x78, 0xbc, 0x46, 0x8a, 0x77, 0xbe, 0xfc, 0xf6, 0xcd, 0x3f,
	0x02, 0xb5, 0x73, 0x50, 0x4e, 0xaa, 0xc5, 0x8b, 0x92, 0xf8, 0xf9, 0xcf, 0xdf, 0xdd, 0x1d, 0x44,
	0x55, 0xa8, 0x24, 0x79, 0xc9, 0x0a, 0x21, 0xbe, 0x71, 0xf3, 0xc6, 0x7b, 0x03, 0x68, 0x21, 0xcd,
	0x4c, 0x3e, 0x57, 0x71, 0xef, 0xc1, 0x8d, 0x0f, 0xff, 0x0c, 0x0c, 0x9c, 0x87, 0xd9, 0x24, 0x3d,
	0xf6, 0x80, 0xc4, 0x7b, 0xb7, 0xf7, 0xde, 0x7d, 0xd8, 0x33, 0x3b, 0x9d, 0xe4, 0x46, 0x77, 0x52,
	0xfc, 0xe8, 0xd6, 0xc7, 0xbf, 0xfd, 0xc5, 0x79, 0xd2, 0xc0, 0xdb, 0xfb, 0xe5, 0x5c, 0xe3, 0x4e,
	0x01, 0x0a, 0xca, 0xe6, 0xf2, 0x8a, 0xee, 0xa1, 0x55, 0xf8, 0x5f, 0xf6, 0x7f, 0xaf, 0xd9, 0xf0,
	0xce, 0x66, 0x9f, 0xa3, 0x14, 0x7f, 0x18, 0x72, 0x0e, 0xbd, 0x14, 0x08, 0xa5, 0xff, 0xb2, 0xc4,
	0x84, 0x52, 0xb0, 0x34, 0x1e, 0x09, 0xf1, 0xaf, 0x72, 0x0e, 0x6d, 0xc1, 0xcc, 0xa9, 0xff, 0x33,
	0x9e, 0xc9, 0x10, 0x4c, 0xb1, 0x32, 0x74, 0x5f, 0x83, 0xe9, 0x93, 0xbb, 0xf6, 0xff, 0xd3, 0xa2,
	0x09, 0x8a, 0x34, 0x15, 0x29, 0xc6, 0x10, 0x39, 0x87, 0x56, 0x40, 0x4c, 0x75, 0xdb, 0xe2, 0x71,
	0xc1, 0xe3, 0x88, 0x34, 0x19, 0xe9, 0x04, 0xfb, 0xb4, 0x42, 0x95, 0x57, 0xa0, 0x78, 0x62, 0xff,
	0xab, 0xa4, 0xed, 0xc5, 0x19, 0xd2, 0x99, 0x48, 0xb5, 0x07, 0xc8, 0x39, 0x74, 0x05, 0xa4, 0x53,
	0xfa, 0x96, 0x9c, 0x16, 0x4d, 0x72, 0xfe, 0x81, 0x6c, 0xaa, 0xe3, 0x64, 0xc8, 0x26, 0x39, 0xd9,
	0xb2, 0x97, 0xe1, 0xec, 0x49, 0xbd, 0x62, 0x2e, 0xad, 0x19, 0x23, 0x64, 0x0b, 0xae, 0xc2, 0x44,
	0x56, 0x8d, 0x2e, 0xa5, 0xc5, 0x22, 0x30, 0x53, 0x68, 0xe9, 0x85, 0x07, 0xbf, 0x94, 0x85, 0x6f,
	0x0e, 0xca, 0xc2, 0x8f, 0x07, 0x65, 0xe1, 0xfe, 0x41, 0x59, 0x78, 0xbd, 0xce, 0x08, 0xb6, 0x3a,
	0x2e, 0xb6, 0x6a, 0x06, 0x8d, 0xc6, 0x0b, 0x1e, 0x71, 0xaf, 0x11, 0xb7, 0x8e, 0x1d, 0xa7, 0xee,
	0x0f, 0x0d, 0x95, 0xd4, 0x35, 0xdd, 0xf3, 0x7f, 0xed, 0x02, 0x17, 0x5d, 0xfc, 0x3b, 0x00, 0x00,
	0xff, 0xff, 0x9b, 0x66, 0x8b, 0x97, 0xa0, 0x0d, 0x00, 0x00,
}

func (this *TLDfsWriteFilePartData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&dfs.TLDfsWriteFilePartData{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Creator: "+fmt.Sprintf("%#v", this.Creator)+",\n")
	s = append(s, "FileId: "+fmt.Sprintf("%#v", this.FileId)+",\n")
	s = append(s, "FilePart: "+fmt.Sprintf("%#v", this.FilePart)+",\n")
	s = append(s, "Bytes: "+fmt.Sprintf("%#v", this.Bytes)+",\n")
	s = append(s, "Big: "+fmt.Sprintf("%#v", this.Big)+",\n")
	if this.FileTotalParts != nil {
		s = append(s, "FileTotalParts: "+fmt.Sprintf("%#v", this.FileTotalParts)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLDfsUploadPhotoFileV2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dfs.TLDfsUploadPhotoFileV2{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Creator: "+fmt.Sprintf("%#v", this.Creator)+",\n")
	if this.File != nil {
		s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLDfsUploadProfilePhotoFileV2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&dfs.TLDfsUploadProfilePhotoFileV2{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Creator: "+fmt.Sprintf("%#v", this.Creator)+",\n")
	if this.File != nil {
		s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	}
	if this.Video != nil {
		s = append(s, "Video: "+fmt.Sprintf("%#v", this.Video)+",\n")
	}
	if this.VideoStartTs != nil {
		s = append(s, "VideoStartTs: "+fmt.Sprintf("%#v", this.VideoStartTs)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLDfsUploadEncryptedFileV2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dfs.TLDfsUploadEncryptedFileV2{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Creator: "+fmt.Sprintf("%#v", this.Creator)+",\n")
	if this.File != nil {
		s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLDfsDownloadFile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dfs.TLDfsDownloadFile{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	if this.Location != nil {
		s = append(s, "Location: "+fmt.Sprintf("%#v", this.Location)+",\n")
	}
	s = append(s, "Offset: "+fmt.Sprintf("%#v", this.Offset)+",\n")
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLDfsUploadDocumentFileV2) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dfs.TLDfsUploadDocumentFileV2{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Creator: "+fmt.Sprintf("%#v", this.Creator)+",\n")
	if this.Media != nil {
		s = append(s, "Media: "+fmt.Sprintf("%#v", this.Media)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLDfsUploadGifDocumentMedia) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dfs.TLDfsUploadGifDocumentMedia{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Creator: "+fmt.Sprintf("%#v", this.Creator)+",\n")
	if this.Media != nil {
		s = append(s, "Media: "+fmt.Sprintf("%#v", this.Media)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLDfsUploadMp4DocumentMedia) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dfs.TLDfsUploadMp4DocumentMedia{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Creator: "+fmt.Sprintf("%#v", this.Creator)+",\n")
	if this.Media != nil {
		s = append(s, "Media: "+fmt.Sprintf("%#v", this.Media)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLDfsUploadWallPaperFile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&dfs.TLDfsUploadWallPaperFile{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Creator: "+fmt.Sprintf("%#v", this.Creator)+",\n")
	if this.File != nil {
		s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	}
	s = append(s, "MimeType: "+fmt.Sprintf("%#v", this.MimeType)+",\n")
	if this.Admin != nil {
		s = append(s, "Admin: "+fmt.Sprintf("%#v", this.Admin)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLDfsUploadThemeFile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&dfs.TLDfsUploadThemeFile{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Creator: "+fmt.Sprintf("%#v", this.Creator)+",\n")
	if this.File != nil {
		s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	}
	if this.Thumb != nil {
		s = append(s, "Thumb: "+fmt.Sprintf("%#v", this.Thumb)+",\n")
	}
	s = append(s, "MimeType: "+fmt.Sprintf("%#v", this.MimeType)+",\n")
	s = append(s, "FileName: "+fmt.Sprintf("%#v", this.FileName)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringDfsTl(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RPCDfsClient is the client API for RPCDfs service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RPCDfsClient interface {
	// dfs.writeFilePartData flags:# creator:long file_id:long file_part:int bytes:bytes big:flags.0?true file_total_parts:flags.1?int = Bool;
	DfsWriteFilePartData(ctx context.Context, in *TLDfsWriteFilePartData, opts ...grpc.CallOption) (*mtproto.Bool, error)
	// dfs.uploadPhotoFileV2 creator:long file:InputFile = Photo;
	DfsUploadPhotoFileV2(ctx context.Context, in *TLDfsUploadPhotoFileV2, opts ...grpc.CallOption) (*mtproto.Photo, error)
	// dfs.uploadProfilePhotoFileV2 flags:# creator:long file:flags.0?InputFile video:flags.1?InputFile video_start_ts:flags.2?double = Photo;
	DfsUploadProfilePhotoFileV2(ctx context.Context, in *TLDfsUploadProfilePhotoFileV2, opts ...grpc.CallOption) (*mtproto.Photo, error)
	// dfs.uploadEncryptedFileV2 creator:long file:InputEncryptedFile = EncryptedFile;
	DfsUploadEncryptedFileV2(ctx context.Context, in *TLDfsUploadEncryptedFileV2, opts ...grpc.CallOption) (*mtproto.EncryptedFile, error)
	// dfs.downloadFile location:InputFileLocation offset:int limit:int = upload.File;
	DfsDownloadFile(ctx context.Context, in *TLDfsDownloadFile, opts ...grpc.CallOption) (*mtproto.Upload_File, error)
	// dfs.uploadDocumentFileV2 creator:long media:InputMedia = Document;
	DfsUploadDocumentFileV2(ctx context.Context, in *TLDfsUploadDocumentFileV2, opts ...grpc.CallOption) (*mtproto.Document, error)
	// dfs.uploadGifDocumentMedia creator:long media:InputMedia = Document;
	DfsUploadGifDocumentMedia(ctx context.Context, in *TLDfsUploadGifDocumentMedia, opts ...grpc.CallOption) (*mtproto.Document, error)
	// dfs.uploadMp4DocumentMedia creator:long media:InputMedia = Document;
	DfsUploadMp4DocumentMedia(ctx context.Context, in *TLDfsUploadMp4DocumentMedia, opts ...grpc.CallOption) (*mtproto.Document, error)
	// dfs.uploadWallPaperFile creator:long file:InputFile mime_type:string admin:Bool = Document;
	DfsUploadWallPaperFile(ctx context.Context, in *TLDfsUploadWallPaperFile, opts ...grpc.CallOption) (*mtproto.Document, error)
	// dfs.uploadThemeFile flags:# creator:long file:InputFile thumb:flags.0?InputFile mime_type:string file_name:string = Document;
	DfsUploadThemeFile(ctx context.Context, in *TLDfsUploadThemeFile, opts ...grpc.CallOption) (*mtproto.Document, error)
}

type rPCDfsClient struct {
	cc *grpc.ClientConn
}

func NewRPCDfsClient(cc *grpc.ClientConn) RPCDfsClient {
	return &rPCDfsClient{cc}
}

func (c *rPCDfsClient) DfsWriteFilePartData(ctx context.Context, in *TLDfsWriteFilePartData, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/dfs.RPCDfs/dfs_writeFilePartData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCDfsClient) DfsUploadPhotoFileV2(ctx context.Context, in *TLDfsUploadPhotoFileV2, opts ...grpc.CallOption) (*mtproto.Photo, error) {
	out := new(mtproto.Photo)
	err := c.cc.Invoke(ctx, "/dfs.RPCDfs/dfs_uploadPhotoFileV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCDfsClient) DfsUploadProfilePhotoFileV2(ctx context.Context, in *TLDfsUploadProfilePhotoFileV2, opts ...grpc.CallOption) (*mtproto.Photo, error) {
	out := new(mtproto.Photo)
	err := c.cc.Invoke(ctx, "/dfs.RPCDfs/dfs_uploadProfilePhotoFileV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCDfsClient) DfsUploadEncryptedFileV2(ctx context.Context, in *TLDfsUploadEncryptedFileV2, opts ...grpc.CallOption) (*mtproto.EncryptedFile, error) {
	out := new(mtproto.EncryptedFile)
	err := c.cc.Invoke(ctx, "/dfs.RPCDfs/dfs_uploadEncryptedFileV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCDfsClient) DfsDownloadFile(ctx context.Context, in *TLDfsDownloadFile, opts ...grpc.CallOption) (*mtproto.Upload_File, error) {
	out := new(mtproto.Upload_File)
	err := c.cc.Invoke(ctx, "/dfs.RPCDfs/dfs_downloadFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCDfsClient) DfsUploadDocumentFileV2(ctx context.Context, in *TLDfsUploadDocumentFileV2, opts ...grpc.CallOption) (*mtproto.Document, error) {
	out := new(mtproto.Document)
	err := c.cc.Invoke(ctx, "/dfs.RPCDfs/dfs_uploadDocumentFileV2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCDfsClient) DfsUploadGifDocumentMedia(ctx context.Context, in *TLDfsUploadGifDocumentMedia, opts ...grpc.CallOption) (*mtproto.Document, error) {
	out := new(mtproto.Document)
	err := c.cc.Invoke(ctx, "/dfs.RPCDfs/dfs_uploadGifDocumentMedia", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCDfsClient) DfsUploadMp4DocumentMedia(ctx context.Context, in *TLDfsUploadMp4DocumentMedia, opts ...grpc.CallOption) (*mtproto.Document, error) {
	out := new(mtproto.Document)
	err := c.cc.Invoke(ctx, "/dfs.RPCDfs/dfs_uploadMp4DocumentMedia", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCDfsClient) DfsUploadWallPaperFile(ctx context.Context, in *TLDfsUploadWallPaperFile, opts ...grpc.CallOption) (*mtproto.Document, error) {
	out := new(mtproto.Document)
	err := c.cc.Invoke(ctx, "/dfs.RPCDfs/dfs_uploadWallPaperFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCDfsClient) DfsUploadThemeFile(ctx context.Context, in *TLDfsUploadThemeFile, opts ...grpc.CallOption) (*mtproto.Document, error) {
	out := new(mtproto.Document)
	err := c.cc.Invoke(ctx, "/dfs.RPCDfs/dfs_uploadThemeFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RPCDfsServer is the server API for RPCDfs service.
type RPCDfsServer interface {
	// dfs.writeFilePartData flags:# creator:long file_id:long file_part:int bytes:bytes big:flags.0?true file_total_parts:flags.1?int = Bool;
	DfsWriteFilePartData(context.Context, *TLDfsWriteFilePartData) (*mtproto.Bool, error)
	// dfs.uploadPhotoFileV2 creator:long file:InputFile = Photo;
	DfsUploadPhotoFileV2(context.Context, *TLDfsUploadPhotoFileV2) (*mtproto.Photo, error)
	// dfs.uploadProfilePhotoFileV2 flags:# creator:long file:flags.0?InputFile video:flags.1?InputFile video_start_ts:flags.2?double = Photo;
	DfsUploadProfilePhotoFileV2(context.Context, *TLDfsUploadProfilePhotoFileV2) (*mtproto.Photo, error)
	// dfs.uploadEncryptedFileV2 creator:long file:InputEncryptedFile = EncryptedFile;
	DfsUploadEncryptedFileV2(context.Context, *TLDfsUploadEncryptedFileV2) (*mtproto.EncryptedFile, error)
	// dfs.downloadFile location:InputFileLocation offset:int limit:int = upload.File;
	DfsDownloadFile(context.Context, *TLDfsDownloadFile) (*mtproto.Upload_File, error)
	// dfs.uploadDocumentFileV2 creator:long media:InputMedia = Document;
	DfsUploadDocumentFileV2(context.Context, *TLDfsUploadDocumentFileV2) (*mtproto.Document, error)
	// dfs.uploadGifDocumentMedia creator:long media:InputMedia = Document;
	DfsUploadGifDocumentMedia(context.Context, *TLDfsUploadGifDocumentMedia) (*mtproto.Document, error)
	// dfs.uploadMp4DocumentMedia creator:long media:InputMedia = Document;
	DfsUploadMp4DocumentMedia(context.Context, *TLDfsUploadMp4DocumentMedia) (*mtproto.Document, error)
	// dfs.uploadWallPaperFile creator:long file:InputFile mime_type:string admin:Bool = Document;
	DfsUploadWallPaperFile(context.Context, *TLDfsUploadWallPaperFile) (*mtproto.Document, error)
	// dfs.uploadThemeFile flags:# creator:long file:InputFile thumb:flags.0?InputFile mime_type:string file_name:string = Document;
	DfsUploadThemeFile(context.Context, *TLDfsUploadThemeFile) (*mtproto.Document, error)
}

// UnimplementedRPCDfsServer can be embedded to have forward compatible implementations.
type UnimplementedRPCDfsServer struct {
}

func (*UnimplementedRPCDfsServer) DfsWriteFilePartData(ctx context.Context, req *TLDfsWriteFilePartData) (*mtproto.Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DfsWriteFilePartData not implemented")
}
func (*UnimplementedRPCDfsServer) DfsUploadPhotoFileV2(ctx context.Context, req *TLDfsUploadPhotoFileV2) (*mtproto.Photo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DfsUploadPhotoFileV2 not implemented")
}
func (*UnimplementedRPCDfsServer) DfsUploadProfilePhotoFileV2(ctx context.Context, req *TLDfsUploadProfilePhotoFileV2) (*mtproto.Photo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DfsUploadProfilePhotoFileV2 not implemented")
}
func (*UnimplementedRPCDfsServer) DfsUploadEncryptedFileV2(ctx context.Context, req *TLDfsUploadEncryptedFileV2) (*mtproto.EncryptedFile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DfsUploadEncryptedFileV2 not implemented")
}
func (*UnimplementedRPCDfsServer) DfsDownloadFile(ctx context.Context, req *TLDfsDownloadFile) (*mtproto.Upload_File, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DfsDownloadFile not implemented")
}
func (*UnimplementedRPCDfsServer) DfsUploadDocumentFileV2(ctx context.Context, req *TLDfsUploadDocumentFileV2) (*mtproto.Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DfsUploadDocumentFileV2 not implemented")
}
func (*UnimplementedRPCDfsServer) DfsUploadGifDocumentMedia(ctx context.Context, req *TLDfsUploadGifDocumentMedia) (*mtproto.Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DfsUploadGifDocumentMedia not implemented")
}
func (*UnimplementedRPCDfsServer) DfsUploadMp4DocumentMedia(ctx context.Context, req *TLDfsUploadMp4DocumentMedia) (*mtproto.Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DfsUploadMp4DocumentMedia not implemented")
}
func (*UnimplementedRPCDfsServer) DfsUploadWallPaperFile(ctx context.Context, req *TLDfsUploadWallPaperFile) (*mtproto.Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DfsUploadWallPaperFile not implemented")
}
func (*UnimplementedRPCDfsServer) DfsUploadThemeFile(ctx context.Context, req *TLDfsUploadThemeFile) (*mtproto.Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DfsUploadThemeFile not implemented")
}

func RegisterRPCDfsServer(s *grpc.Server, srv RPCDfsServer) {
	s.RegisterService(&_RPCDfs_serviceDesc, srv)
}

func _RPCDfs_DfsWriteFilePartData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLDfsWriteFilePartData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCDfsServer).DfsWriteFilePartData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dfs.RPCDfs/DfsWriteFilePartData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCDfsServer).DfsWriteFilePartData(ctx, req.(*TLDfsWriteFilePartData))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCDfs_DfsUploadPhotoFileV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLDfsUploadPhotoFileV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCDfsServer).DfsUploadPhotoFileV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dfs.RPCDfs/DfsUploadPhotoFileV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCDfsServer).DfsUploadPhotoFileV2(ctx, req.(*TLDfsUploadPhotoFileV2))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCDfs_DfsUploadProfilePhotoFileV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLDfsUploadProfilePhotoFileV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCDfsServer).DfsUploadProfilePhotoFileV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dfs.RPCDfs/DfsUploadProfilePhotoFileV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCDfsServer).DfsUploadProfilePhotoFileV2(ctx, req.(*TLDfsUploadProfilePhotoFileV2))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCDfs_DfsUploadEncryptedFileV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLDfsUploadEncryptedFileV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCDfsServer).DfsUploadEncryptedFileV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dfs.RPCDfs/DfsUploadEncryptedFileV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCDfsServer).DfsUploadEncryptedFileV2(ctx, req.(*TLDfsUploadEncryptedFileV2))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCDfs_DfsDownloadFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLDfsDownloadFile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCDfsServer).DfsDownloadFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dfs.RPCDfs/DfsDownloadFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCDfsServer).DfsDownloadFile(ctx, req.(*TLDfsDownloadFile))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCDfs_DfsUploadDocumentFileV2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLDfsUploadDocumentFileV2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCDfsServer).DfsUploadDocumentFileV2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dfs.RPCDfs/DfsUploadDocumentFileV2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCDfsServer).DfsUploadDocumentFileV2(ctx, req.(*TLDfsUploadDocumentFileV2))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCDfs_DfsUploadGifDocumentMedia_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLDfsUploadGifDocumentMedia)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCDfsServer).DfsUploadGifDocumentMedia(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dfs.RPCDfs/DfsUploadGifDocumentMedia",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCDfsServer).DfsUploadGifDocumentMedia(ctx, req.(*TLDfsUploadGifDocumentMedia))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCDfs_DfsUploadMp4DocumentMedia_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLDfsUploadMp4DocumentMedia)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCDfsServer).DfsUploadMp4DocumentMedia(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dfs.RPCDfs/DfsUploadMp4DocumentMedia",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCDfsServer).DfsUploadMp4DocumentMedia(ctx, req.(*TLDfsUploadMp4DocumentMedia))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCDfs_DfsUploadWallPaperFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLDfsUploadWallPaperFile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCDfsServer).DfsUploadWallPaperFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dfs.RPCDfs/DfsUploadWallPaperFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCDfsServer).DfsUploadWallPaperFile(ctx, req.(*TLDfsUploadWallPaperFile))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCDfs_DfsUploadThemeFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLDfsUploadThemeFile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCDfsServer).DfsUploadThemeFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dfs.RPCDfs/DfsUploadThemeFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCDfsServer).DfsUploadThemeFile(ctx, req.(*TLDfsUploadThemeFile))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPCDfs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dfs.RPCDfs",
	HandlerType: (*RPCDfsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "dfs_writeFilePartData",
			Handler:    _RPCDfs_DfsWriteFilePartData_Handler,
		},
		{
			MethodName: "dfs_uploadPhotoFileV2",
			Handler:    _RPCDfs_DfsUploadPhotoFileV2_Handler,
		},
		{
			MethodName: "dfs_uploadProfilePhotoFileV2",
			Handler:    _RPCDfs_DfsUploadProfilePhotoFileV2_Handler,
		},
		{
			MethodName: "dfs_uploadEncryptedFileV2",
			Handler:    _RPCDfs_DfsUploadEncryptedFileV2_Handler,
		},
		{
			MethodName: "dfs_downloadFile",
			Handler:    _RPCDfs_DfsDownloadFile_Handler,
		},
		{
			MethodName: "dfs_uploadDocumentFileV2",
			Handler:    _RPCDfs_DfsUploadDocumentFileV2_Handler,
		},
		{
			MethodName: "dfs_uploadGifDocumentMedia",
			Handler:    _RPCDfs_DfsUploadGifDocumentMedia_Handler,
		},
		{
			MethodName: "dfs_uploadMp4DocumentMedia",
			Handler:    _RPCDfs_DfsUploadMp4DocumentMedia_Handler,
		},
		{
			MethodName: "dfs_uploadWallPaperFile",
			Handler:    _RPCDfs_DfsUploadWallPaperFile_Handler,
		},
		{
			MethodName: "dfs_uploadThemeFile",
			Handler:    _RPCDfs_DfsUploadThemeFile_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "dfs.tl.proto",
}

func (m *TLDfsWriteFilePartData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLDfsWriteFilePartData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLDfsWriteFilePartData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FileTotalParts != nil {
		{
			size, err := m.FileTotalParts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDfsTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Big {
		i--
		if m.Big {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Bytes) > 0 {
		i -= len(m.Bytes)
		copy(dAtA[i:], m.Bytes)
		i = encodeVarintDfsTl(dAtA, i, uint64(len(m.Bytes)))
		i--
		dAtA[i] = 0x32
	}
	if m.FilePart != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.FilePart))
		i--
		dAtA[i] = 0x28
	}
	if m.FileId != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.FileId))
		i--
		dAtA[i] = 0x20
	}
	if m.Creator != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Creator))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLDfsUploadPhotoFileV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLDfsUploadPhotoFileV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLDfsUploadPhotoFileV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDfsTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Creator != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Creator))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLDfsUploadProfilePhotoFileV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLDfsUploadProfilePhotoFileV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLDfsUploadProfilePhotoFileV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.VideoStartTs != nil {
		{
			size, err := m.VideoStartTs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDfsTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Video != nil {
		{
			size, err := m.Video.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDfsTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDfsTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Creator != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Creator))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLDfsUploadEncryptedFileV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLDfsUploadEncryptedFileV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLDfsUploadEncryptedFileV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDfsTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Creator != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Creator))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLDfsDownloadFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLDfsDownloadFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLDfsDownloadFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x28
	}
	if m.Offset != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x20
	}
	if m.Location != nil {
		{
			size, err := m.Location.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDfsTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLDfsUploadDocumentFileV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLDfsUploadDocumentFileV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLDfsUploadDocumentFileV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Media != nil {
		{
			size, err := m.Media.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDfsTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Creator != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Creator))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLDfsUploadGifDocumentMedia) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLDfsUploadGifDocumentMedia) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLDfsUploadGifDocumentMedia) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Media != nil {
		{
			size, err := m.Media.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDfsTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Creator != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Creator))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLDfsUploadMp4DocumentMedia) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLDfsUploadMp4DocumentMedia) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLDfsUploadMp4DocumentMedia) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Media != nil {
		{
			size, err := m.Media.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDfsTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Creator != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Creator))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLDfsUploadWallPaperFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLDfsUploadWallPaperFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLDfsUploadWallPaperFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Admin != nil {
		{
			size, err := m.Admin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDfsTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.MimeType) > 0 {
		i -= len(m.MimeType)
		copy(dAtA[i:], m.MimeType)
		i = encodeVarintDfsTl(dAtA, i, uint64(len(m.MimeType)))
		i--
		dAtA[i] = 0x2a
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDfsTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Creator != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Creator))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLDfsUploadThemeFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLDfsUploadThemeFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLDfsUploadThemeFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintDfsTl(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.MimeType) > 0 {
		i -= len(m.MimeType)
		copy(dAtA[i:], m.MimeType)
		i = encodeVarintDfsTl(dAtA, i, uint64(len(m.MimeType)))
		i--
		dAtA[i] = 0x32
	}
	if m.Thumb != nil {
		{
			size, err := m.Thumb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDfsTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDfsTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Creator != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Creator))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintDfsTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDfsTl(dAtA []byte, offset int, v uint64) int {
	offset -= sovDfsTl(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TLDfsWriteFilePartData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovDfsTl(uint64(m.Constructor))
	}
	if m.Creator != 0 {
		n += 1 + sovDfsTl(uint64(m.Creator))
	}
	if m.FileId != 0 {
		n += 1 + sovDfsTl(uint64(m.FileId))
	}
	if m.FilePart != 0 {
		n += 1 + sovDfsTl(uint64(m.FilePart))
	}
	l = len(m.Bytes)
	if l > 0 {
		n += 1 + l + sovDfsTl(uint64(l))
	}
	if m.Big {
		n += 2
	}
	if m.FileTotalParts != nil {
		l = m.FileTotalParts.Size()
		n += 1 + l + sovDfsTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLDfsUploadPhotoFileV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovDfsTl(uint64(m.Constructor))
	}
	if m.Creator != 0 {
		n += 1 + sovDfsTl(uint64(m.Creator))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovDfsTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLDfsUploadProfilePhotoFileV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovDfsTl(uint64(m.Constructor))
	}
	if m.Creator != 0 {
		n += 1 + sovDfsTl(uint64(m.Creator))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovDfsTl(uint64(l))
	}
	if m.Video != nil {
		l = m.Video.Size()
		n += 1 + l + sovDfsTl(uint64(l))
	}
	if m.VideoStartTs != nil {
		l = m.VideoStartTs.Size()
		n += 1 + l + sovDfsTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLDfsUploadEncryptedFileV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovDfsTl(uint64(m.Constructor))
	}
	if m.Creator != 0 {
		n += 1 + sovDfsTl(uint64(m.Creator))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovDfsTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLDfsDownloadFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovDfsTl(uint64(m.Constructor))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovDfsTl(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovDfsTl(uint64(m.Offset))
	}
	if m.Limit != 0 {
		n += 1 + sovDfsTl(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLDfsUploadDocumentFileV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovDfsTl(uint64(m.Constructor))
	}
	if m.Creator != 0 {
		n += 1 + sovDfsTl(uint64(m.Creator))
	}
	if m.Media != nil {
		l = m.Media.Size()
		n += 1 + l + sovDfsTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLDfsUploadGifDocumentMedia) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovDfsTl(uint64(m.Constructor))
	}
	if m.Creator != 0 {
		n += 1 + sovDfsTl(uint64(m.Creator))
	}
	if m.Media != nil {
		l = m.Media.Size()
		n += 1 + l + sovDfsTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLDfsUploadMp4DocumentMedia) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovDfsTl(uint64(m.Constructor))
	}
	if m.Creator != 0 {
		n += 1 + sovDfsTl(uint64(m.Creator))
	}
	if m.Media != nil {
		l = m.Media.Size()
		n += 1 + l + sovDfsTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLDfsUploadWallPaperFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovDfsTl(uint64(m.Constructor))
	}
	if m.Creator != 0 {
		n += 1 + sovDfsTl(uint64(m.Creator))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovDfsTl(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovDfsTl(uint64(l))
	}
	if m.Admin != nil {
		l = m.Admin.Size()
		n += 1 + l + sovDfsTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLDfsUploadThemeFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovDfsTl(uint64(m.Constructor))
	}
	if m.Creator != 0 {
		n += 1 + sovDfsTl(uint64(m.Creator))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovDfsTl(uint64(l))
	}
	if m.Thumb != nil {
		l = m.Thumb.Size()
		n += 1 + l + sovDfsTl(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovDfsTl(uint64(l))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovDfsTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovDfsTl(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDfsTl(x uint64) (n int) {
	return sovDfsTl(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TLDfsWriteFilePartData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfsTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_dfs_writeFilePartData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_dfs_writeFilePartData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			m.Creator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Creator |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePart", wireType)
			}
			m.FilePart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilePart |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDfsTl
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDfsTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Bytes = append(m.Bytes[:0], dAtA[iNdEx:postIndex]...)
			if m.Bytes == nil {
				m.Bytes = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Big", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Big = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileTotalParts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDfsTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDfsTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileTotalParts == nil {
				m.FileTotalParts = &types.Int32Value{}
			}
			if err := m.FileTotalParts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDfsTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfsTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLDfsUploadPhotoFileV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfsTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_dfs_uploadPhotoFileV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_dfs_uploadPhotoFileV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			m.Creator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Creator |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDfsTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDfsTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &mtproto.InputFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDfsTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfsTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLDfsUploadProfilePhotoFileV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfsTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_dfs_uploadProfilePhotoFileV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_dfs_uploadProfilePhotoFileV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			m.Creator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Creator |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDfsTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDfsTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &mtproto.InputFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDfsTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDfsTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Video == nil {
				m.Video = &mtproto.InputFile{}
			}
			if err := m.Video.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoStartTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDfsTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDfsTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VideoStartTs == nil {
				m.VideoStartTs = &types.DoubleValue{}
			}
			if err := m.VideoStartTs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDfsTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfsTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLDfsUploadEncryptedFileV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfsTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_dfs_uploadEncryptedFileV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_dfs_uploadEncryptedFileV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			m.Creator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Creator |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDfsTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDfsTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &mtproto.InputEncryptedFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDfsTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfsTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLDfsDownloadFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfsTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_dfs_downloadFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_dfs_downloadFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDfsTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDfsTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &mtproto.InputFileLocation{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDfsTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfsTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLDfsUploadDocumentFileV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfsTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_dfs_uploadDocumentFileV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_dfs_uploadDocumentFileV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			m.Creator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Creator |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDfsTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDfsTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Media == nil {
				m.Media = &mtproto.InputMedia{}
			}
			if err := m.Media.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDfsTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfsTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLDfsUploadGifDocumentMedia) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfsTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_dfs_uploadGifDocumentMedia: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_dfs_uploadGifDocumentMedia: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			m.Creator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Creator |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDfsTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDfsTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Media == nil {
				m.Media = &mtproto.InputMedia{}
			}
			if err := m.Media.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDfsTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfsTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLDfsUploadMp4DocumentMedia) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfsTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_dfs_uploadMp4DocumentMedia: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_dfs_uploadMp4DocumentMedia: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			m.Creator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Creator |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDfsTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDfsTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Media == nil {
				m.Media = &mtproto.InputMedia{}
			}
			if err := m.Media.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDfsTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfsTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLDfsUploadWallPaperFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfsTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_dfs_uploadWallPaperFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_dfs_uploadWallPaperFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			m.Creator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Creator |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDfsTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDfsTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &mtproto.InputFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDfsTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDfsTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDfsTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDfsTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Admin == nil {
				m.Admin = &mtproto.Bool{}
			}
			if err := m.Admin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDfsTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfsTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLDfsUploadThemeFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDfsTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_dfs_uploadThemeFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_dfs_uploadThemeFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			m.Creator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Creator |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDfsTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDfsTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &mtproto.InputFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDfsTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDfsTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumb == nil {
				m.Thumb = &mtproto.InputFile{}
			}
			if err := m.Thumb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDfsTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDfsTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDfsTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDfsTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDfsTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDfsTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDfsTl(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDfsTl
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDfsTl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDfsTl
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDfsTl
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDfsTl
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDfsTl        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDfsTl          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDfsTl = fmt.Errorf("proto: unexpected end of group")
)
