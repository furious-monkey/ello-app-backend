// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: media.tl.proto

package media

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	mtproto "github.com/teamgram/proto/mtproto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TLConstructor int32

const (
	CRC32_UNKNOWN                      TLConstructor = 0
	CRC32_photoSizeList                TLConstructor = 108083635
	CRC32_videoSizeList                TLConstructor = 953261042
	CRC32_media_uploadPhotoFile        TLConstructor = 1009453847
	CRC32_media_uploadProfilePhotoFile TLConstructor = -1757466844
	CRC32_media_getPhoto               TLConstructor = 1702803563
	CRC32_media_getPhotoSizeList       TLConstructor = -1578401979
	CRC32_media_getPhotoSizeListList   TLConstructor = -77823776
	CRC32_media_getVideoSizeList       TLConstructor = -998862102
	CRC32_media_uploadedDocumentMedia  TLConstructor = 1331671148
	CRC32_media_getDocument            TLConstructor = 1072011085
	CRC32_media_getDocumentList        TLConstructor = -986721681
	CRC32_media_uploadEncryptedFile    TLConstructor = -1426012517
	CRC32_media_getEncryptedFile       TLConstructor = -60784431
	CRC32_media_uploadWallPaperFile    TLConstructor = -1661293058
	CRC32_media_uploadThemeFile        TLConstructor = 1122416736
	CRC32_media_uploadStickerFile      TLConstructor = -1397349139
)

var TLConstructor_name = map[int32]string{
	0:           "CRC32_UNKNOWN",
	108083635:   "CRC32_photoSizeList",
	953261042:   "CRC32_videoSizeList",
	1009453847:  "CRC32_media_uploadPhotoFile",
	-1757466844: "CRC32_media_uploadProfilePhotoFile",
	1702803563:  "CRC32_media_getPhoto",
	-1578401979: "CRC32_media_getPhotoSizeList",
	-77823776:   "CRC32_media_getPhotoSizeListList",
	-998862102:  "CRC32_media_getVideoSizeList",
	1331671148:  "CRC32_media_uploadedDocumentMedia",
	1072011085:  "CRC32_media_getDocument",
	-986721681:  "CRC32_media_getDocumentList",
	-1426012517: "CRC32_media_uploadEncryptedFile",
	-60784431:   "CRC32_media_getEncryptedFile",
	-1661293058: "CRC32_media_uploadWallPaperFile",
	1122416736:  "CRC32_media_uploadThemeFile",
	-1397349139: "CRC32_media_uploadStickerFile",
}

var TLConstructor_value = map[string]int32{
	"CRC32_UNKNOWN":                      0,
	"CRC32_photoSizeList":                108083635,
	"CRC32_videoSizeList":                953261042,
	"CRC32_media_uploadPhotoFile":        1009453847,
	"CRC32_media_uploadProfilePhotoFile": -1757466844,
	"CRC32_media_getPhoto":               1702803563,
	"CRC32_media_getPhotoSizeList":       -1578401979,
	"CRC32_media_getPhotoSizeListList":   -77823776,
	"CRC32_media_getVideoSizeList":       -998862102,
	"CRC32_media_uploadedDocumentMedia":  1331671148,
	"CRC32_media_getDocument":            1072011085,
	"CRC32_media_getDocumentList":        -986721681,
	"CRC32_media_uploadEncryptedFile":    -1426012517,
	"CRC32_media_getEncryptedFile":       -60784431,
	"CRC32_media_uploadWallPaperFile":    -1661293058,
	"CRC32_media_uploadThemeFile":        1122416736,
	"CRC32_media_uploadStickerFile":      -1397349139,
}

func (x TLConstructor) String() string {
	return proto.EnumName(TLConstructor_name, int32(x))
}

func (TLConstructor) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{0}
}

//--------------------------------------------------------------------------------------------
// photoSizeList size_id:long sizes:Vector<PhotoSize> dc_id:int = PhotoSizeList;
//
// PhotoSizeList <--
//  + TL_photoSizeList
//
type PhotoSizeList struct {
	PredicateName        string               `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor        `protobuf:"varint,2,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	SizeId               int64                `protobuf:"varint,3,opt,name=size_id,json=sizeId,proto3" json:"size_id,omitempty"`
	Sizes                []*mtproto.PhotoSize `protobuf:"bytes,4,rep,name=sizes,proto3" json:"sizes,omitempty"`
	DcId                 int32                `protobuf:"varint,5,opt,name=dc_id,json=dcId,proto3" json:"dc_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *PhotoSizeList) Reset()         { *m = PhotoSizeList{} }
func (m *PhotoSizeList) String() string { return proto.CompactTextString(m) }
func (*PhotoSizeList) ProtoMessage()    {}
func (*PhotoSizeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{0}
}
func (m *PhotoSizeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhotoSizeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhotoSizeList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhotoSizeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhotoSizeList.Merge(m, src)
}
func (m *PhotoSizeList) XXX_Size() int {
	return m.Size()
}
func (m *PhotoSizeList) XXX_DiscardUnknown() {
	xxx_messageInfo_PhotoSizeList.DiscardUnknown(m)
}

var xxx_messageInfo_PhotoSizeList proto.InternalMessageInfo

func (m *PhotoSizeList) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *PhotoSizeList) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *PhotoSizeList) GetSizeId() int64 {
	if m != nil {
		return m.SizeId
	}
	return 0
}

func (m *PhotoSizeList) GetSizes() []*mtproto.PhotoSize {
	if m != nil {
		return m.Sizes
	}
	return nil
}

func (m *PhotoSizeList) GetDcId() int32 {
	if m != nil {
		return m.DcId
	}
	return 0
}

// photoSizeList size_id:long sizes:Vector<PhotoSize> dc_id:int = PhotoSizeList;
type TLPhotoSizeList struct {
	Data2                *PhotoSizeList `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TLPhotoSizeList) Reset()         { *m = TLPhotoSizeList{} }
func (m *TLPhotoSizeList) String() string { return proto.CompactTextString(m) }
func (*TLPhotoSizeList) ProtoMessage()    {}
func (*TLPhotoSizeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{1}
}
func (m *TLPhotoSizeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLPhotoSizeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLPhotoSizeList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLPhotoSizeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLPhotoSizeList.Merge(m, src)
}
func (m *TLPhotoSizeList) XXX_Size() int {
	return m.Size()
}
func (m *TLPhotoSizeList) XXX_DiscardUnknown() {
	xxx_messageInfo_TLPhotoSizeList.DiscardUnknown(m)
}

var xxx_messageInfo_TLPhotoSizeList proto.InternalMessageInfo

func (m *TLPhotoSizeList) GetData2() *PhotoSizeList {
	if m != nil {
		return m.Data2
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// videoSizeList size_id:long sizes:Vector<VideoSize> dc_id:int = VideoSizeList;
//
// VideoSizeList <--
//  + TL_videoSizeList
//
type VideoSizeList struct {
	PredicateName        string               `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor        `protobuf:"varint,2,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	SizeId               int64                `protobuf:"varint,3,opt,name=size_id,json=sizeId,proto3" json:"size_id,omitempty"`
	Sizes                []*mtproto.VideoSize `protobuf:"bytes,4,rep,name=sizes,proto3" json:"sizes,omitempty"`
	DcId                 int32                `protobuf:"varint,5,opt,name=dc_id,json=dcId,proto3" json:"dc_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *VideoSizeList) Reset()         { *m = VideoSizeList{} }
func (m *VideoSizeList) String() string { return proto.CompactTextString(m) }
func (*VideoSizeList) ProtoMessage()    {}
func (*VideoSizeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{2}
}
func (m *VideoSizeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VideoSizeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VideoSizeList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VideoSizeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VideoSizeList.Merge(m, src)
}
func (m *VideoSizeList) XXX_Size() int {
	return m.Size()
}
func (m *VideoSizeList) XXX_DiscardUnknown() {
	xxx_messageInfo_VideoSizeList.DiscardUnknown(m)
}

var xxx_messageInfo_VideoSizeList proto.InternalMessageInfo

func (m *VideoSizeList) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *VideoSizeList) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *VideoSizeList) GetSizeId() int64 {
	if m != nil {
		return m.SizeId
	}
	return 0
}

func (m *VideoSizeList) GetSizes() []*mtproto.VideoSize {
	if m != nil {
		return m.Sizes
	}
	return nil
}

func (m *VideoSizeList) GetDcId() int32 {
	if m != nil {
		return m.DcId
	}
	return 0
}

// videoSizeList size_id:long sizes:Vector<VideoSize> dc_id:int = VideoSizeList;
type TLVideoSizeList struct {
	Data2                *VideoSizeList `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TLVideoSizeList) Reset()         { *m = TLVideoSizeList{} }
func (m *TLVideoSizeList) String() string { return proto.CompactTextString(m) }
func (*TLVideoSizeList) ProtoMessage()    {}
func (*TLVideoSizeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{3}
}
func (m *TLVideoSizeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLVideoSizeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLVideoSizeList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLVideoSizeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLVideoSizeList.Merge(m, src)
}
func (m *TLVideoSizeList) XXX_Size() int {
	return m.Size()
}
func (m *TLVideoSizeList) XXX_DiscardUnknown() {
	xxx_messageInfo_TLVideoSizeList.DiscardUnknown(m)
}

var xxx_messageInfo_TLVideoSizeList proto.InternalMessageInfo

func (m *TLVideoSizeList) GetData2() *VideoSizeList {
	if m != nil {
		return m.Data2
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// media.uploadPhotoFile flags:# owner_id:long file:InputFile stickers:flags.0?Vector<InputDocument> ttl_seconds:flags.1?int = Photo;
type TLMediaUploadPhotoFile struct {
	Constructor          TLConstructor            `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	OwnerId              int64                    `protobuf:"varint,3,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	File                 *mtproto.InputFile       `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	Stickers             []*mtproto.InputDocument `protobuf:"bytes,5,rep,name=stickers,proto3" json:"stickers,omitempty"`
	TtlSeconds           *types.Int32Value        `protobuf:"bytes,6,opt,name=ttl_seconds,json=ttlSeconds,proto3" json:"ttl_seconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *TLMediaUploadPhotoFile) Reset()         { *m = TLMediaUploadPhotoFile{} }
func (m *TLMediaUploadPhotoFile) String() string { return proto.CompactTextString(m) }
func (*TLMediaUploadPhotoFile) ProtoMessage()    {}
func (*TLMediaUploadPhotoFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{4}
}
func (m *TLMediaUploadPhotoFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaUploadPhotoFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaUploadPhotoFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaUploadPhotoFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaUploadPhotoFile.Merge(m, src)
}
func (m *TLMediaUploadPhotoFile) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaUploadPhotoFile) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaUploadPhotoFile.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaUploadPhotoFile proto.InternalMessageInfo

func (m *TLMediaUploadPhotoFile) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaUploadPhotoFile) GetOwnerId() int64 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *TLMediaUploadPhotoFile) GetFile() *mtproto.InputFile {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *TLMediaUploadPhotoFile) GetStickers() []*mtproto.InputDocument {
	if m != nil {
		return m.Stickers
	}
	return nil
}

func (m *TLMediaUploadPhotoFile) GetTtlSeconds() *types.Int32Value {
	if m != nil {
		return m.TtlSeconds
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// media.uploadProfilePhotoFile flags:# owner_id:long file:flags.0?InputFile video:flags.1?InputFile video_start_ts:flags.2?double = Photo;
type TLMediaUploadProfilePhotoFile struct {
	Constructor          TLConstructor      `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	OwnerId              int64              `protobuf:"varint,3,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	File                 *mtproto.InputFile `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	Video                *mtproto.InputFile `protobuf:"bytes,5,opt,name=video,proto3" json:"video,omitempty"`
	VideoStartTs         *types.DoubleValue `protobuf:"bytes,6,opt,name=video_start_ts,json=videoStartTs,proto3" json:"video_start_ts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TLMediaUploadProfilePhotoFile) Reset()         { *m = TLMediaUploadProfilePhotoFile{} }
func (m *TLMediaUploadProfilePhotoFile) String() string { return proto.CompactTextString(m) }
func (*TLMediaUploadProfilePhotoFile) ProtoMessage()    {}
func (*TLMediaUploadProfilePhotoFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{5}
}
func (m *TLMediaUploadProfilePhotoFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaUploadProfilePhotoFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaUploadProfilePhotoFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaUploadProfilePhotoFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaUploadProfilePhotoFile.Merge(m, src)
}
func (m *TLMediaUploadProfilePhotoFile) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaUploadProfilePhotoFile) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaUploadProfilePhotoFile.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaUploadProfilePhotoFile proto.InternalMessageInfo

func (m *TLMediaUploadProfilePhotoFile) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaUploadProfilePhotoFile) GetOwnerId() int64 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *TLMediaUploadProfilePhotoFile) GetFile() *mtproto.InputFile {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *TLMediaUploadProfilePhotoFile) GetVideo() *mtproto.InputFile {
	if m != nil {
		return m.Video
	}
	return nil
}

func (m *TLMediaUploadProfilePhotoFile) GetVideoStartTs() *types.DoubleValue {
	if m != nil {
		return m.VideoStartTs
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// media.getPhoto photo_id:long = Photo;
type TLMediaGetPhoto struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	PhotoId              int64         `protobuf:"varint,3,opt,name=photo_id,json=photoId,proto3" json:"photo_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLMediaGetPhoto) Reset()         { *m = TLMediaGetPhoto{} }
func (m *TLMediaGetPhoto) String() string { return proto.CompactTextString(m) }
func (*TLMediaGetPhoto) ProtoMessage()    {}
func (*TLMediaGetPhoto) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{6}
}
func (m *TLMediaGetPhoto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaGetPhoto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaGetPhoto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaGetPhoto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaGetPhoto.Merge(m, src)
}
func (m *TLMediaGetPhoto) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaGetPhoto) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaGetPhoto.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaGetPhoto proto.InternalMessageInfo

func (m *TLMediaGetPhoto) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaGetPhoto) GetPhotoId() int64 {
	if m != nil {
		return m.PhotoId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// media.getPhotoSizeList size_id:long = PhotoSizeList;
type TLMediaGetPhotoSizeList struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	SizeId               int64         `protobuf:"varint,3,opt,name=size_id,json=sizeId,proto3" json:"size_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLMediaGetPhotoSizeList) Reset()         { *m = TLMediaGetPhotoSizeList{} }
func (m *TLMediaGetPhotoSizeList) String() string { return proto.CompactTextString(m) }
func (*TLMediaGetPhotoSizeList) ProtoMessage()    {}
func (*TLMediaGetPhotoSizeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{7}
}
func (m *TLMediaGetPhotoSizeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaGetPhotoSizeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaGetPhotoSizeList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaGetPhotoSizeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaGetPhotoSizeList.Merge(m, src)
}
func (m *TLMediaGetPhotoSizeList) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaGetPhotoSizeList) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaGetPhotoSizeList.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaGetPhotoSizeList proto.InternalMessageInfo

func (m *TLMediaGetPhotoSizeList) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaGetPhotoSizeList) GetSizeId() int64 {
	if m != nil {
		return m.SizeId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// media.getPhotoSizeListList id_list:Vector<long> = Vector<PhotoSizeList>;
type TLMediaGetPhotoSizeListList struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	IdList               []int64       `protobuf:"varint,3,rep,packed,name=id_list,json=idList,proto3" json:"id_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLMediaGetPhotoSizeListList) Reset()         { *m = TLMediaGetPhotoSizeListList{} }
func (m *TLMediaGetPhotoSizeListList) String() string { return proto.CompactTextString(m) }
func (*TLMediaGetPhotoSizeListList) ProtoMessage()    {}
func (*TLMediaGetPhotoSizeListList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{8}
}
func (m *TLMediaGetPhotoSizeListList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaGetPhotoSizeListList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaGetPhotoSizeListList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaGetPhotoSizeListList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaGetPhotoSizeListList.Merge(m, src)
}
func (m *TLMediaGetPhotoSizeListList) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaGetPhotoSizeListList) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaGetPhotoSizeListList.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaGetPhotoSizeListList proto.InternalMessageInfo

func (m *TLMediaGetPhotoSizeListList) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaGetPhotoSizeListList) GetIdList() []int64 {
	if m != nil {
		return m.IdList
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// media.getVideoSizeList size_id:long = VideoSizeList;
type TLMediaGetVideoSizeList struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	SizeId               int64         `protobuf:"varint,3,opt,name=size_id,json=sizeId,proto3" json:"size_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLMediaGetVideoSizeList) Reset()         { *m = TLMediaGetVideoSizeList{} }
func (m *TLMediaGetVideoSizeList) String() string { return proto.CompactTextString(m) }
func (*TLMediaGetVideoSizeList) ProtoMessage()    {}
func (*TLMediaGetVideoSizeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{9}
}
func (m *TLMediaGetVideoSizeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaGetVideoSizeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaGetVideoSizeList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaGetVideoSizeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaGetVideoSizeList.Merge(m, src)
}
func (m *TLMediaGetVideoSizeList) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaGetVideoSizeList) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaGetVideoSizeList.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaGetVideoSizeList proto.InternalMessageInfo

func (m *TLMediaGetVideoSizeList) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaGetVideoSizeList) GetSizeId() int64 {
	if m != nil {
		return m.SizeId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// media.uploadedDocumentMedia owner_id:long media:InputMedia = MessageMedia;
type TLMediaUploadedDocumentMedia struct {
	Constructor          TLConstructor       `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	OwnerId              int64               `protobuf:"varint,3,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	Media                *mtproto.InputMedia `protobuf:"bytes,4,opt,name=media,proto3" json:"media,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TLMediaUploadedDocumentMedia) Reset()         { *m = TLMediaUploadedDocumentMedia{} }
func (m *TLMediaUploadedDocumentMedia) String() string { return proto.CompactTextString(m) }
func (*TLMediaUploadedDocumentMedia) ProtoMessage()    {}
func (*TLMediaUploadedDocumentMedia) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{10}
}
func (m *TLMediaUploadedDocumentMedia) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaUploadedDocumentMedia) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaUploadedDocumentMedia.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaUploadedDocumentMedia) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaUploadedDocumentMedia.Merge(m, src)
}
func (m *TLMediaUploadedDocumentMedia) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaUploadedDocumentMedia) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaUploadedDocumentMedia.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaUploadedDocumentMedia proto.InternalMessageInfo

func (m *TLMediaUploadedDocumentMedia) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaUploadedDocumentMedia) GetOwnerId() int64 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *TLMediaUploadedDocumentMedia) GetMedia() *mtproto.InputMedia {
	if m != nil {
		return m.Media
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// media.getDocument id:long = Document;
type TLMediaGetDocument struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	Id                   int64         `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLMediaGetDocument) Reset()         { *m = TLMediaGetDocument{} }
func (m *TLMediaGetDocument) String() string { return proto.CompactTextString(m) }
func (*TLMediaGetDocument) ProtoMessage()    {}
func (*TLMediaGetDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{11}
}
func (m *TLMediaGetDocument) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaGetDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaGetDocument.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaGetDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaGetDocument.Merge(m, src)
}
func (m *TLMediaGetDocument) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaGetDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaGetDocument.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaGetDocument proto.InternalMessageInfo

func (m *TLMediaGetDocument) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaGetDocument) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// media.getDocumentList id_list:Vector<long> = Vector<Document>;
type TLMediaGetDocumentList struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	IdList               []int64       `protobuf:"varint,3,rep,packed,name=id_list,json=idList,proto3" json:"id_list,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLMediaGetDocumentList) Reset()         { *m = TLMediaGetDocumentList{} }
func (m *TLMediaGetDocumentList) String() string { return proto.CompactTextString(m) }
func (*TLMediaGetDocumentList) ProtoMessage()    {}
func (*TLMediaGetDocumentList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{12}
}
func (m *TLMediaGetDocumentList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaGetDocumentList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaGetDocumentList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaGetDocumentList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaGetDocumentList.Merge(m, src)
}
func (m *TLMediaGetDocumentList) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaGetDocumentList) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaGetDocumentList.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaGetDocumentList proto.InternalMessageInfo

func (m *TLMediaGetDocumentList) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaGetDocumentList) GetIdList() []int64 {
	if m != nil {
		return m.IdList
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// media.uploadEncryptedFile owner_id:long file:InputEncryptedFile = EncryptedFile;
type TLMediaUploadEncryptedFile struct {
	Constructor          TLConstructor               `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	OwnerId              int64                       `protobuf:"varint,3,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	File                 *mtproto.InputEncryptedFile `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *TLMediaUploadEncryptedFile) Reset()         { *m = TLMediaUploadEncryptedFile{} }
func (m *TLMediaUploadEncryptedFile) String() string { return proto.CompactTextString(m) }
func (*TLMediaUploadEncryptedFile) ProtoMessage()    {}
func (*TLMediaUploadEncryptedFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{13}
}
func (m *TLMediaUploadEncryptedFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaUploadEncryptedFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaUploadEncryptedFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaUploadEncryptedFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaUploadEncryptedFile.Merge(m, src)
}
func (m *TLMediaUploadEncryptedFile) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaUploadEncryptedFile) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaUploadEncryptedFile.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaUploadEncryptedFile proto.InternalMessageInfo

func (m *TLMediaUploadEncryptedFile) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaUploadEncryptedFile) GetOwnerId() int64 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *TLMediaUploadEncryptedFile) GetFile() *mtproto.InputEncryptedFile {
	if m != nil {
		return m.File
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// media.getEncryptedFile id:long access_hash:long = EncryptedFile;
type TLMediaGetEncryptedFile struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	Id                   int64         `protobuf:"varint,3,opt,name=id,proto3" json:"id,omitempty"`
	AccessHash           int64         `protobuf:"varint,4,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLMediaGetEncryptedFile) Reset()         { *m = TLMediaGetEncryptedFile{} }
func (m *TLMediaGetEncryptedFile) String() string { return proto.CompactTextString(m) }
func (*TLMediaGetEncryptedFile) ProtoMessage()    {}
func (*TLMediaGetEncryptedFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{14}
}
func (m *TLMediaGetEncryptedFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaGetEncryptedFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaGetEncryptedFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaGetEncryptedFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaGetEncryptedFile.Merge(m, src)
}
func (m *TLMediaGetEncryptedFile) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaGetEncryptedFile) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaGetEncryptedFile.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaGetEncryptedFile proto.InternalMessageInfo

func (m *TLMediaGetEncryptedFile) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaGetEncryptedFile) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TLMediaGetEncryptedFile) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// media.uploadWallPaperFile owner_id:long file:InputFile mime_type:string admin:Bool = Document;
type TLMediaUploadWallPaperFile struct {
	Constructor          TLConstructor      `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	OwnerId              int64              `protobuf:"varint,3,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	File                 *mtproto.InputFile `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	MimeType             string             `protobuf:"bytes,5,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	Admin                *mtproto.Bool      `protobuf:"bytes,6,opt,name=admin,proto3" json:"admin,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TLMediaUploadWallPaperFile) Reset()         { *m = TLMediaUploadWallPaperFile{} }
func (m *TLMediaUploadWallPaperFile) String() string { return proto.CompactTextString(m) }
func (*TLMediaUploadWallPaperFile) ProtoMessage()    {}
func (*TLMediaUploadWallPaperFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{15}
}
func (m *TLMediaUploadWallPaperFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaUploadWallPaperFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaUploadWallPaperFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaUploadWallPaperFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaUploadWallPaperFile.Merge(m, src)
}
func (m *TLMediaUploadWallPaperFile) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaUploadWallPaperFile) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaUploadWallPaperFile.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaUploadWallPaperFile proto.InternalMessageInfo

func (m *TLMediaUploadWallPaperFile) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaUploadWallPaperFile) GetOwnerId() int64 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *TLMediaUploadWallPaperFile) GetFile() *mtproto.InputFile {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *TLMediaUploadWallPaperFile) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *TLMediaUploadWallPaperFile) GetAdmin() *mtproto.Bool {
	if m != nil {
		return m.Admin
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// media.uploadThemeFile flags:# owner_id:long file:InputFile thumb:flags.0?InputFile mime_type:string file_name:string = Document;
type TLMediaUploadThemeFile struct {
	Constructor          TLConstructor      `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	OwnerId              int64              `protobuf:"varint,3,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	File                 *mtproto.InputFile `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	Thumb                *mtproto.InputFile `protobuf:"bytes,5,opt,name=thumb,proto3" json:"thumb,omitempty"`
	MimeType             string             `protobuf:"bytes,6,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	FileName             string             `protobuf:"bytes,7,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *TLMediaUploadThemeFile) Reset()         { *m = TLMediaUploadThemeFile{} }
func (m *TLMediaUploadThemeFile) String() string { return proto.CompactTextString(m) }
func (*TLMediaUploadThemeFile) ProtoMessage()    {}
func (*TLMediaUploadThemeFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{16}
}
func (m *TLMediaUploadThemeFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaUploadThemeFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaUploadThemeFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaUploadThemeFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaUploadThemeFile.Merge(m, src)
}
func (m *TLMediaUploadThemeFile) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaUploadThemeFile) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaUploadThemeFile.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaUploadThemeFile proto.InternalMessageInfo

func (m *TLMediaUploadThemeFile) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaUploadThemeFile) GetOwnerId() int64 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *TLMediaUploadThemeFile) GetFile() *mtproto.InputFile {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *TLMediaUploadThemeFile) GetThumb() *mtproto.InputFile {
	if m != nil {
		return m.Thumb
	}
	return nil
}

func (m *TLMediaUploadThemeFile) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *TLMediaUploadThemeFile) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

//--------------------------------------------------------------------------------------------
// media.uploadStickerFile flags:# owner_id:long file:InputFile thumb:flags.0?InputFile mime_type:string file_name:string document_attribute_sticker:DocumentAttribute = Document;
type TLMediaUploadStickerFile struct {
	Constructor              TLConstructor              `protobuf:"varint,1,opt,name=constructor,proto3,enum=media.TLConstructor" json:"constructor,omitempty"`
	OwnerId                  int64                      `protobuf:"varint,3,opt,name=owner_id,json=ownerId,proto3" json:"owner_id,omitempty"`
	File                     *mtproto.InputFile         `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	Thumb                    *mtproto.InputFile         `protobuf:"bytes,5,opt,name=thumb,proto3" json:"thumb,omitempty"`
	MimeType                 string                     `protobuf:"bytes,6,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	FileName                 string                     `protobuf:"bytes,7,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	DocumentAttributeSticker *mtproto.DocumentAttribute `protobuf:"bytes,8,opt,name=document_attribute_sticker,json=documentAttributeSticker,proto3" json:"document_attribute_sticker,omitempty"`
	XXX_NoUnkeyedLiteral     struct{}                   `json:"-"`
	XXX_unrecognized         []byte                     `json:"-"`
	XXX_sizecache            int32                      `json:"-"`
}

func (m *TLMediaUploadStickerFile) Reset()         { *m = TLMediaUploadStickerFile{} }
func (m *TLMediaUploadStickerFile) String() string { return proto.CompactTextString(m) }
func (*TLMediaUploadStickerFile) ProtoMessage()    {}
func (*TLMediaUploadStickerFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{17}
}
func (m *TLMediaUploadStickerFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMediaUploadStickerFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMediaUploadStickerFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMediaUploadStickerFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMediaUploadStickerFile.Merge(m, src)
}
func (m *TLMediaUploadStickerFile) XXX_Size() int {
	return m.Size()
}
func (m *TLMediaUploadStickerFile) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMediaUploadStickerFile.DiscardUnknown(m)
}

var xxx_messageInfo_TLMediaUploadStickerFile proto.InternalMessageInfo

func (m *TLMediaUploadStickerFile) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLMediaUploadStickerFile) GetOwnerId() int64 {
	if m != nil {
		return m.OwnerId
	}
	return 0
}

func (m *TLMediaUploadStickerFile) GetFile() *mtproto.InputFile {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *TLMediaUploadStickerFile) GetThumb() *mtproto.InputFile {
	if m != nil {
		return m.Thumb
	}
	return nil
}

func (m *TLMediaUploadStickerFile) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *TLMediaUploadStickerFile) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *TLMediaUploadStickerFile) GetDocumentAttributeSticker() *mtproto.DocumentAttribute {
	if m != nil {
		return m.DocumentAttributeSticker
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// Vector api result type
type Vector_PhotoSizeList struct {
	Datas                []*PhotoSizeList `protobuf:"bytes,1,rep,name=datas,proto3" json:"datas,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Vector_PhotoSizeList) Reset()         { *m = Vector_PhotoSizeList{} }
func (m *Vector_PhotoSizeList) String() string { return proto.CompactTextString(m) }
func (*Vector_PhotoSizeList) ProtoMessage()    {}
func (*Vector_PhotoSizeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{18}
}
func (m *Vector_PhotoSizeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vector_PhotoSizeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vector_PhotoSizeList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vector_PhotoSizeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vector_PhotoSizeList.Merge(m, src)
}
func (m *Vector_PhotoSizeList) XXX_Size() int {
	return m.Size()
}
func (m *Vector_PhotoSizeList) XXX_DiscardUnknown() {
	xxx_messageInfo_Vector_PhotoSizeList.DiscardUnknown(m)
}

var xxx_messageInfo_Vector_PhotoSizeList proto.InternalMessageInfo

func (m *Vector_PhotoSizeList) GetDatas() []*PhotoSizeList {
	if m != nil {
		return m.Datas
	}
	return nil
}

type Vector_Document struct {
	Datas                []*mtproto.Document `protobuf:"bytes,1,rep,name=datas,proto3" json:"datas,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *Vector_Document) Reset()         { *m = Vector_Document{} }
func (m *Vector_Document) String() string { return proto.CompactTextString(m) }
func (*Vector_Document) ProtoMessage()    {}
func (*Vector_Document) Descriptor() ([]byte, []int) {
	return fileDescriptor_c788ef787fa9e2c6, []int{19}
}
func (m *Vector_Document) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vector_Document) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vector_Document.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vector_Document) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vector_Document.Merge(m, src)
}
func (m *Vector_Document) XXX_Size() int {
	return m.Size()
}
func (m *Vector_Document) XXX_DiscardUnknown() {
	xxx_messageInfo_Vector_Document.DiscardUnknown(m)
}

var xxx_messageInfo_Vector_Document proto.InternalMessageInfo

func (m *Vector_Document) GetDatas() []*mtproto.Document {
	if m != nil {
		return m.Datas
	}
	return nil
}

func init() {
	proto.RegisterEnum("media.TLConstructor", TLConstructor_name, TLConstructor_value)
	proto.RegisterType((*PhotoSizeList)(nil), "media.PhotoSizeList")
	proto.RegisterType((*TLPhotoSizeList)(nil), "media.TL_photoSizeList")
	proto.RegisterType((*VideoSizeList)(nil), "media.VideoSizeList")
	proto.RegisterType((*TLVideoSizeList)(nil), "media.TL_videoSizeList")
	proto.RegisterType((*TLMediaUploadPhotoFile)(nil), "media.TL_media_uploadPhotoFile")
	proto.RegisterType((*TLMediaUploadProfilePhotoFile)(nil), "media.TL_media_uploadProfilePhotoFile")
	proto.RegisterType((*TLMediaGetPhoto)(nil), "media.TL_media_getPhoto")
	proto.RegisterType((*TLMediaGetPhotoSizeList)(nil), "media.TL_media_getPhotoSizeList")
	proto.RegisterType((*TLMediaGetPhotoSizeListList)(nil), "media.TL_media_getPhotoSizeListList")
	proto.RegisterType((*TLMediaGetVideoSizeList)(nil), "media.TL_media_getVideoSizeList")
	proto.RegisterType((*TLMediaUploadedDocumentMedia)(nil), "media.TL_media_uploadedDocumentMedia")
	proto.RegisterType((*TLMediaGetDocument)(nil), "media.TL_media_getDocument")
	proto.RegisterType((*TLMediaGetDocumentList)(nil), "media.TL_media_getDocumentList")
	proto.RegisterType((*TLMediaUploadEncryptedFile)(nil), "media.TL_media_uploadEncryptedFile")
	proto.RegisterType((*TLMediaGetEncryptedFile)(nil), "media.TL_media_getEncryptedFile")
	proto.RegisterType((*TLMediaUploadWallPaperFile)(nil), "media.TL_media_uploadWallPaperFile")
	proto.RegisterType((*TLMediaUploadThemeFile)(nil), "media.TL_media_uploadThemeFile")
	proto.RegisterType((*TLMediaUploadStickerFile)(nil), "media.TL_media_uploadStickerFile")
	proto.RegisterType((*Vector_PhotoSizeList)(nil), "media.Vector_PhotoSizeList")
	proto.RegisterType((*Vector_Document)(nil), "media.Vector_Document")
}

func init() { proto.RegisterFile("media.tl.proto", fileDescriptor_c788ef787fa9e2c6) }

var fileDescriptor_c788ef787fa9e2c6 = []byte{
	// 1440 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x58, 0x5d, 0x88, 0x1b, 0x55,
	0x14, 0xce, 0x6c, 0x92, 0xed, 0xee, 0x59, 0x77, 0x9d, 0xbd, 0xdd, 0xb6, 0xd9, 0xc9, 0x36, 0x9b,
	0x4e, 0x6d, 0x4d, 0x8b, 0x4d, 0x20, 0x0b, 0x3e, 0x48, 0x11, 0xdc, 0x6d, 0xc5, 0xd5, 0xed, 0xba,
	0x4e, 0xd3, 0x1f, 0x0a, 0x3a, 0xcc, 0xce, 0xdc, 0x26, 0x43, 0x67, 0x32, 0xc3, 0xcc, 0x4d, 0xcb,
	0xf6, 0xad, 0x2a, 0x28, 0x82, 0xf8, 0xd6, 0x82, 0x42, 0x1f, 0x6c, 0x05, 0xc5, 0x9f, 0x17, 0x1f,
	0xc4, 0x27, 0x5f, 0xb4, 0xe8, 0x83, 0xa0, 0x0f, 0x42, 0x69, 0x41, 0xb6, 0x15, 0x11, 0xaa, 0x62,
	0xa9, 0x4f, 0x5d, 0x4a, 0x23, 0x73, 0x27, 0x33, 0xc9, 0x9d, 0x4c, 0x62, 0xe9, 0x0f, 0x16, 0x7c,
	0x09, 0x33, 0xf7, 0x7c, 0xf3, 0x9d, 0x73, 0xbe, 0x7b, 0xef, 0xb9, 0xe7, 0x06, 0xc6, 0x4c, 0xac,
	0xe9, 0x4a, 0x91, 0x18, 0x45, 0xdb, 0xb1, 0x88, 0x85, 0xd2, 0xf4, 0x5d, 0xd8, 0x55, 0xd5, 0x49,
	0xad, 0xb1, 0x5c, 0x54, 0x2d, 0xb3, 0x54, 0xb5, 0xaa, 0x56, 0x89, 0x5a, 0x97, 0x1b, 0x47, 0xe9,
	0x1b, 0x7d, 0xa1, 0x4f, 0xfe, 0x57, 0x42, 0xae, 0x6a, 0x59, 0x55, 0x03, 0xb7, 0x51, 0x27, 0x1c,
	0xc5, 0xb6, 0xb1, 0xe3, 0xb6, 0xec, 0x82, 0xab, 0xd6, 0xb0, 0x49, 0xdd, 0xa8, 0x96, 0x83, 0x65,
	0xb2, 0x62, 0xe3, 0xc0, 0x36, 0xd9, 0xb6, 0x11, 0x47, 0xa9, 0xbb, 0xb6, 0xe5, 0x90, 0x96, 0x69,
	0xa2, 0x6d, 0x72, 0x57, 0xea, 0xaa, 0x3f, 0x2a, 0x5e, 0xe0, 0x60, 0x74, 0xa9, 0x66, 0x11, 0x6b,
	0xbf, 0x7e, 0x12, 0x2f, 0xe8, 0x2e, 0x41, 0xdb, 0x60, 0xcc, 0x76, 0xb0, 0xa6, 0xab, 0x0a, 0xc1,
	0x72, 0x5d, 0x31, 0x71, 0x86, 0xcb, 0x73, 0x85, 0x61, 0x69, 0x34, 0x1c, 0x5d, 0x54, 0x4c, 0x8c,
	0x9e, 0x84, 0x11, 0xd5, 0xaa, 0xbb, 0xc4, 0x69, 0xa8, 0xc4, 0x72, 0x32, 0x03, 0x79, 0xae, 0x30,
	0x56, 0x9e, 0x28, 0xfa, 0x0a, 0x54, 0x16, 0xe6, 0xda, 0x36, 0xa9, 0x13, 0x88, 0x36, 0xc1, 0x3a,
	0x57, 0x3f, 0x89, 0x65, 0x5d, 0xcb, 0x24, 0xf3, 0x5c, 0x21, 0x29, 0x0d, 0x7a, 0xaf, 0xf3, 0x1a,
	0x2a, 0x40, 0xda, 0x7b, 0x72, 0x33, 0xa9, 0x7c, 0xb2, 0x30, 0x52, 0x46, 0x45, 0x93, 0xd0, 0x10,
	0x8b, 0x61, 0x78, 0x92, 0x0f, 0x40, 0xeb, 0x21, 0xad, 0xa9, 0x1e, 0x41, 0x3a, 0xcf, 0x15, 0xd2,
	0x52, 0x4a, 0x53, 0xe7, 0x35, 0xf1, 0x69, 0xe0, 0x2b, 0x0b, 0xb2, 0xcd, 0xa4, 0xb2, 0x13, 0xd2,
	0x9a, 0x42, 0x94, 0x32, 0xcd, 0x60, 0x24, 0x8c, 0x8e, 0xc9, 0x57, 0xf2, 0x21, 0x54, 0x88, 0x83,
	0xba, 0x86, 0x1f, 0x62, 0x21, 0xc2, 0xf0, 0xee, 0x40, 0x88, 0xe3, 0x4c, 0x2a, 0x3d, 0x84, 0x60,
	0xf2, 0x0d, 0x84, 0x78, 0x63, 0x00, 0x32, 0x95, 0x05, 0x99, 0x22, 0xe4, 0x86, 0x6d, 0x58, 0x8a,
	0x46, 0x05, 0x7b, 0x56, 0x37, 0xba, 0x92, 0xe5, 0xee, 0x34, 0xd9, 0x49, 0x18, 0xb2, 0x4e, 0xd4,
	0xb1, 0xd3, 0xce, 0x76, 0x1d, 0x7d, 0x9f, 0xd7, 0xd0, 0x76, 0x48, 0x1d, 0xd5, 0x0d, 0x9c, 0x49,
	0xd1, 0xd0, 0xda, 0xd9, 0xce, 0xd7, 0xed, 0x06, 0xf1, 0x9c, 0x4a, 0xd4, 0x8e, 0xca, 0x30, 0xe4,
	0x12, 0x5d, 0x3d, 0x86, 0x1d, 0x37, 0x93, 0xa6, 0xca, 0x6c, 0x64, 0xb1, 0x7b, 0x2c, 0xb5, 0x61,
	0xe2, 0x3a, 0x91, 0x42, 0x1c, 0xda, 0x0d, 0x23, 0x84, 0x18, 0xb2, 0x8b, 0x55, 0xab, 0xae, 0xb9,
	0x99, 0x41, 0xea, 0x22, 0x5b, 0xf4, 0x37, 0x58, 0x31, 0xd8, 0x60, 0xc5, 0xf9, 0x3a, 0x99, 0x29,
	0x1f, 0x54, 0x8c, 0x06, 0x96, 0x80, 0x10, 0x63, 0xbf, 0x0f, 0x17, 0xdf, 0x1a, 0x80, 0xe9, 0xa8,
	0x12, 0x8e, 0xe5, 0x05, 0xf3, 0x50, 0x08, 0x52, 0x80, 0x34, 0x9d, 0x65, 0x3a, 0xfb, 0xf1, 0x40,
	0x1f, 0x80, 0x66, 0x61, 0x8c, 0x3e, 0xc8, 0x2e, 0x51, 0x1c, 0x22, 0x93, 0x40, 0x89, 0xa9, 0x2e,
	0x25, 0xf6, 0x58, 0x8d, 0x65, 0x03, 0xfb, 0x52, 0x3c, 0xe2, 0xaf, 0x21, 0xef, 0x93, 0x8a, 0x2b,
	0x1e, 0x85, 0xf1, 0x50, 0x8b, 0x2a, 0x26, 0x54, 0x81, 0x7b, 0xc9, 0x9e, 0xee, 0xd4, 0x8e, 0xec,
	0xe9, 0xfb, 0xbc, 0x26, 0x1a, 0x30, 0xd9, 0xe5, 0x27, 0x5c, 0xc7, 0x77, 0xeb, 0xaf, 0xd7, 0x5e,
	0x13, 0x6d, 0xd8, 0xdc, 0xd3, 0xdb, 0xbd, 0x7a, 0xd4, 0x35, 0xd9, 0xd0, 0x5d, 0x92, 0x49, 0xe6,
	0x93, 0x9e, 0x47, 0x5d, 0xf3, 0x08, 0xa3, 0xf9, 0xb1, 0x25, 0xe7, 0xbe, 0xe7, 0x77, 0x96, 0x83,
	0x5c, 0x64, 0x09, 0x63, 0x2d, 0xd8, 0x28, 0xfb, 0xbc, 0xd1, 0x07, 0xb1, 0x82, 0x77, 0x80, 0x7f,
	0xf2, 0xb5, 0x96, 0xf0, 0x7a, 0x76, 0x65, 0x52, 0xb7, 0x92, 0x8f, 0x10, 0x5f, 0x81, 0x89, 0x4e,
	0x39, 0x82, 0xd0, 0xee, 0x3a, 0xaa, 0x31, 0x18, 0x08, 0xe3, 0x19, 0xd0, 0x35, 0xf1, 0x58, 0x47,
	0x31, 0xeb, 0xe0, 0x7f, 0x30, 0x73, 0xfb, 0x3e, 0x07, 0x53, 0x11, 0xb5, 0xf7, 0xd6, 0x55, 0x67,
	0xc5, 0x26, 0x58, 0x7b, 0x50, 0xd5, 0xa2, 0xc4, 0x54, 0x8b, 0x2c, 0x2b, 0x35, 0xe3, 0xdd, 0x2f,
	0x1b, 0xe2, 0xeb, 0x1c, 0xbb, 0x02, 0xef, 0x4f, 0x84, 0x11, 0xdd, 0xd1, 0x34, 0x8c, 0x28, 0xaa,
	0x8a, 0x5d, 0x57, 0xae, 0x29, 0x6e, 0x8d, 0x46, 0x97, 0x94, 0xc0, 0x1f, 0x7a, 0x4e, 0x71, 0x6b,
	0xe2, 0xe5, 0x6e, 0xad, 0x0e, 0x29, 0x86, 0xb1, 0xa4, 0xd8, 0xd8, 0xf9, 0xaf, 0x2b, 0x6b, 0x16,
	0x86, 0x4d, 0xdd, 0xf4, 0x3b, 0x2b, 0x5a, 0x5d, 0x87, 0xa5, 0x21, 0x6f, 0xa0, 0xb2, 0x62, 0x63,
	0xb4, 0x15, 0xd2, 0x8a, 0x66, 0xea, 0xf5, 0x56, 0x0d, 0x1d, 0x0d, 0x59, 0x66, 0x2d, 0xcb, 0x90,
	0x7c, 0x9b, 0x78, 0x93, 0xeb, 0x3a, 0x44, 0x2b, 0x35, 0x6c, 0xe2, 0x87, 0xe0, 0xcc, 0x20, 0xb5,
	0x86, 0xb9, 0xdc, 0xef, 0xcc, 0xa0, 0x00, 0x56, 0x83, 0xc1, 0x88, 0x06, 0x59, 0x18, 0xf6, 0xe8,
	0xfc, 0xae, 0x68, 0x9d, 0x6f, 0xf4, 0x06, 0xbc, 0x86, 0x48, 0xfc, 0x69, 0x00, 0x84, 0x48, 0xee,
	0xfb, 0xfd, 0x03, 0xf9, 0x7f, 0x90, 0x3d, 0x3a, 0x0c, 0x82, 0xd6, 0x2a, 0x32, 0xb2, 0x42, 0x88,
	0xa3, 0x2f, 0x37, 0x08, 0x96, 0x5b, 0x1d, 0x49, 0x66, 0x88, 0x3a, 0x16, 0x42, 0xc7, 0x41, 0x3d,
	0x7a, 0x26, 0x40, 0x4a, 0x19, 0x2d, 0x3a, 0xd4, 0x12, 0x4f, 0x9c, 0x85, 0x89, 0x83, 0xd8, 0x93,
	0x42, 0x5e, 0x8a, 0xeb, 0x72, 0xdd, 0x0c, 0x47, 0xbb, 0xa2, 0x3e, 0x5d, 0xae, 0x2b, 0x3e, 0x05,
	0x8f, 0xb6, 0x38, 0xc2, 0x4a, 0xfb, 0x38, 0xfb, 0xf9, 0x78, 0x57, 0x6c, 0xad, 0x6f, 0x77, 0x7e,
	0x98, 0x86, 0x51, 0x66, 0x7e, 0xd0, 0x38, 0x8c, 0xce, 0x49, 0x73, 0x33, 0x65, 0xf9, 0xc0, 0xe2,
	0x0b, 0x8b, 0x2f, 0x1e, 0x5a, 0xe4, 0x13, 0x48, 0x80, 0xf5, 0xfe, 0x10, 0xd3, 0x89, 0xf3, 0x9f,
	0xff, 0xfd, 0xf5, 0x0c, 0xca, 0x06, 0x36, 0xa6, 0x39, 0xe5, 0x6f, 0x7c, 0x71, 0xe1, 0x42, 0x12,
	0x6d, 0x85, 0xac, 0x6f, 0x8c, 0x6d, 0x3c, 0xf9, 0x33, 0xa7, 0x3f, 0xb9, 0x92, 0x44, 0x25, 0x10,
	0x63, 0x40, 0x91, 0x9e, 0x8c, 0x3f, 0xff, 0xf3, 0xad, 0x2f, 0x6f, 0x36, 0x9b, 0xcd, 0x26, 0x87,
	0xa6, 0x60, 0xa2, 0xf3, 0x83, 0xe0, 0x88, 0xe7, 0x7f, 0xbf, 0xbe, 0xf6, 0xf1, 0x20, 0xda, 0x01,
	0x53, 0x71, 0xd6, 0x30, 0xb2, 0x6f, 0x6e, 0x7f, 0xfa, 0xce, 0x9a, 0x4f, 0xb4, 0x0b, 0xf2, 0xfd,
	0xa0, 0x14, 0xbe, 0x7a, 0xea, 0xc6, 0xa5, 0xa6, 0x0f, 0xef, 0x66, 0x66, 0x0e, 0x7a, 0xfe, 0xda,
	0x07, 0x97, 0xce, 0xdd, 0x0a, 0xa0, 0x5b, 0xba, 0x73, 0x8a, 0x1c, 0xd2, 0xfc, 0x1f, 0xab, 0xb7,
	0xd7, 0x52, 0x68, 0x1a, 0x36, 0x45, 0x58, 0x03, 0x14, 0xff, 0xfd, 0x67, 0xa7, 0x9b, 0x49, 0x54,
	0x60, 0x45, 0x8c, 0x1c, 0x78, 0xfc, 0x5f, 0xe7, 0xbf, 0xfa, 0xa8, 0xe5, 0xf5, 0x09, 0x98, 0xee,
	0xf6, 0xca, 0x1c, 0x05, 0xfc, 0x7b, 0x6f, 0xbf, 0x76, 0x71, 0xad, 0x57, 0x3a, 0x2c, 0xf4, 0xc7,
	0x53, 0xaf, 0xfe, 0xd2, 0xec, 0x43, 0xcc, 0x54, 0x76, 0xfe, 0xf6, 0xe5, 0x6b, 0xbf, 0xb5, 0xe6,
	0x27, 0x76, 0xd6, 0xc3, 0x4a, 0xc9, 0xaf, 0x5e, 0x7f, 0xf7, 0x4c, 0x0a, 0xed, 0x84, 0xcd, 0xdd,
	0xa0, 0x8e, 0x92, 0xc2, 0xff, 0xf9, 0xdd, 0xc5, 0x5f, 0xfd, 0x48, 0x85, 0xd4, 0x9b, 0xe7, 0x72,
	0x89, 0xf2, 0xd9, 0x61, 0x18, 0x92, 0x96, 0xe6, 0xfc, 0x06, 0xe7, 0x79, 0xd8, 0x10, 0x7f, 0x99,
	0x99, 0x0e, 0x8b, 0x4e, 0xfc, 0xa2, 0x13, 0xc6, 0xd8, 0x3b, 0xa8, 0x98, 0x40, 0x87, 0x61, 0xaa,
	0xef, 0x75, 0x60, 0x7b, 0x0f, 0xca, 0x08, 0x2e, 0x86, 0x79, 0x77, 0xeb, 0xdf, 0x83, 0x76, 0x73,
	0x9d, 0x89, 0x72, 0x05, 0x96, 0x98, 0xaf, 0x25, 0xd8, 0xd8, 0xa3, 0x65, 0xce, 0xf7, 0x62, 0x09,
	0x10, 0x42, 0x6c, 0xc1, 0x10, 0x13, 0x48, 0x01, 0xa1, 0x4f, 0x63, 0xfc, 0xd8, 0xbf, 0xf1, 0x52,
	0xee, 0x6c, 0x70, 0xd3, 0x8c, 0x29, 0x5c, 0x91, 0xb0, 0xd9, 0x4e, 0x38, 0x2e, 0x6c, 0x06, 0x21,
	0xc4, 0x5e, 0x62, 0xc5, 0x04, 0x7a, 0x19, 0xb2, 0xfd, 0xda, 0xdd, 0x6d, 0xf1, 0x33, 0x14, 0x81,
	0x09, 0x1b, 0x42, 0x89, 0xf7, 0x61, 0xd7, 0x55, 0xaa, 0x98, 0x0e, 0x8b, 0x09, 0xb4, 0x17, 0xc6,
	0xbb, 0xbb, 0xd5, 0x6c, 0x4c, 0xb4, 0x81, 0x51, 0xe8, 0xae, 0xa8, 0x34, 0xf3, 0x0d, 0xf1, 0x4d,
	0xe9, 0x74, 0x1f, 0x2a, 0x9a, 0xf7, 0x46, 0x56, 0xd2, 0x0e, 0xce, 0x23, 0x30, 0xd9, 0xbb, 0xf5,
	0xdc, 0x1a, 0x9f, 0x37, 0x03, 0x12, 0xda, 0x37, 0x6a, 0x66, 0x5c, 0x4c, 0xa0, 0x4a, 0xc7, 0x4c,
	0xb1, 0xc4, 0x71, 0x33, 0x75, 0xa7, 0xac, 0x07, 0xd8, 0x88, 0xd9, 0x06, 0xb0, 0x47, 0xc4, 0x0c,
	0x28, 0x5e, 0xdc, 0x7d, 0xec, 0x8e, 0x6f, 0x77, 0x5e, 0x3d, 0x76, 0x7c, 0x08, 0x88, 0xa7, 0x7b,
	0x09, 0x36, 0xf5, 0x6a, 0x66, 0xb6, 0xc4, 0x13, 0x76, 0x40, 0x62, 0x29, 0x67, 0xf7, 0x5e, 0xbf,
	0x92, 0xe3, 0xbe, 0xbd, 0x9a, 0xe3, 0x7e, 0xb8, 0x9a, 0xe3, 0x56, 0xaf, 0xe6, 0xb8, 0x23, 0x33,
	0x04, 0x2b, 0x66, 0xd5, 0x51, 0xcc, 0xa2, 0x6e, 0x95, 0x82, 0xe7, 0x5d, 0x2e, 0x76, 0x8e, 0x63,
	0xa7, 0xa4, 0xd8, 0x76, 0xc9, 0x7b, 0xd4, 0x55, 0x5c, 0xa2, 0x7e, 0xfc, 0xdf, 0xe5, 0x41, 0x4a,
	0x3c, 0xf3, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x50, 0xa7, 0xc6, 0xdb, 0x79, 0x14, 0x00, 0x00,
}

func (this *PhotoSizeList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&media.PhotoSizeList{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "SizeId: "+fmt.Sprintf("%#v", this.SizeId)+",\n")
	if this.Sizes != nil {
		s = append(s, "Sizes: "+fmt.Sprintf("%#v", this.Sizes)+",\n")
	}
	s = append(s, "DcId: "+fmt.Sprintf("%#v", this.DcId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLPhotoSizeList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&media.TLPhotoSizeList{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *VideoSizeList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&media.VideoSizeList{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "SizeId: "+fmt.Sprintf("%#v", this.SizeId)+",\n")
	if this.Sizes != nil {
		s = append(s, "Sizes: "+fmt.Sprintf("%#v", this.Sizes)+",\n")
	}
	s = append(s, "DcId: "+fmt.Sprintf("%#v", this.DcId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLVideoSizeList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&media.TLVideoSizeList{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaUploadPhotoFile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&media.TLMediaUploadPhotoFile{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "OwnerId: "+fmt.Sprintf("%#v", this.OwnerId)+",\n")
	if this.File != nil {
		s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	}
	if this.Stickers != nil {
		s = append(s, "Stickers: "+fmt.Sprintf("%#v", this.Stickers)+",\n")
	}
	if this.TtlSeconds != nil {
		s = append(s, "TtlSeconds: "+fmt.Sprintf("%#v", this.TtlSeconds)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaUploadProfilePhotoFile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&media.TLMediaUploadProfilePhotoFile{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "OwnerId: "+fmt.Sprintf("%#v", this.OwnerId)+",\n")
	if this.File != nil {
		s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	}
	if this.Video != nil {
		s = append(s, "Video: "+fmt.Sprintf("%#v", this.Video)+",\n")
	}
	if this.VideoStartTs != nil {
		s = append(s, "VideoStartTs: "+fmt.Sprintf("%#v", this.VideoStartTs)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaGetPhoto) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&media.TLMediaGetPhoto{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "PhotoId: "+fmt.Sprintf("%#v", this.PhotoId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaGetPhotoSizeList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&media.TLMediaGetPhotoSizeList{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "SizeId: "+fmt.Sprintf("%#v", this.SizeId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaGetPhotoSizeListList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&media.TLMediaGetPhotoSizeListList{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "IdList: "+fmt.Sprintf("%#v", this.IdList)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaGetVideoSizeList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&media.TLMediaGetVideoSizeList{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "SizeId: "+fmt.Sprintf("%#v", this.SizeId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaUploadedDocumentMedia) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&media.TLMediaUploadedDocumentMedia{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "OwnerId: "+fmt.Sprintf("%#v", this.OwnerId)+",\n")
	if this.Media != nil {
		s = append(s, "Media: "+fmt.Sprintf("%#v", this.Media)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaGetDocument) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&media.TLMediaGetDocument{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaGetDocumentList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&media.TLMediaGetDocumentList{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "IdList: "+fmt.Sprintf("%#v", this.IdList)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaUploadEncryptedFile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&media.TLMediaUploadEncryptedFile{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "OwnerId: "+fmt.Sprintf("%#v", this.OwnerId)+",\n")
	if this.File != nil {
		s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaGetEncryptedFile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&media.TLMediaGetEncryptedFile{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "AccessHash: "+fmt.Sprintf("%#v", this.AccessHash)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaUploadWallPaperFile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&media.TLMediaUploadWallPaperFile{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "OwnerId: "+fmt.Sprintf("%#v", this.OwnerId)+",\n")
	if this.File != nil {
		s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	}
	s = append(s, "MimeType: "+fmt.Sprintf("%#v", this.MimeType)+",\n")
	if this.Admin != nil {
		s = append(s, "Admin: "+fmt.Sprintf("%#v", this.Admin)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaUploadThemeFile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&media.TLMediaUploadThemeFile{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "OwnerId: "+fmt.Sprintf("%#v", this.OwnerId)+",\n")
	if this.File != nil {
		s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	}
	if this.Thumb != nil {
		s = append(s, "Thumb: "+fmt.Sprintf("%#v", this.Thumb)+",\n")
	}
	s = append(s, "MimeType: "+fmt.Sprintf("%#v", this.MimeType)+",\n")
	s = append(s, "FileName: "+fmt.Sprintf("%#v", this.FileName)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLMediaUploadStickerFile) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&media.TLMediaUploadStickerFile{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "OwnerId: "+fmt.Sprintf("%#v", this.OwnerId)+",\n")
	if this.File != nil {
		s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	}
	if this.Thumb != nil {
		s = append(s, "Thumb: "+fmt.Sprintf("%#v", this.Thumb)+",\n")
	}
	s = append(s, "MimeType: "+fmt.Sprintf("%#v", this.MimeType)+",\n")
	s = append(s, "FileName: "+fmt.Sprintf("%#v", this.FileName)+",\n")
	if this.DocumentAttributeSticker != nil {
		s = append(s, "DocumentAttributeSticker: "+fmt.Sprintf("%#v", this.DocumentAttributeSticker)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Vector_PhotoSizeList) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&media.Vector_PhotoSizeList{")
	if this.Datas != nil {
		s = append(s, "Datas: "+fmt.Sprintf("%#v", this.Datas)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Vector_Document) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&media.Vector_Document{")
	if this.Datas != nil {
		s = append(s, "Datas: "+fmt.Sprintf("%#v", this.Datas)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringMediaTl(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RPCMediaClient is the client API for RPCMedia service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RPCMediaClient interface {
	// media.uploadPhotoFile flags:# owner_id:long file:InputFile stickers:flags.0?Vector<InputDocument> ttl_seconds:flags.1?int = Photo;
	MediaUploadPhotoFile(ctx context.Context, in *TLMediaUploadPhotoFile, opts ...grpc.CallOption) (*mtproto.Photo, error)
	// media.uploadProfilePhotoFile flags:# owner_id:long file:flags.0?InputFile video:flags.1?InputFile video_start_ts:flags.2?double = Photo;
	MediaUploadProfilePhotoFile(ctx context.Context, in *TLMediaUploadProfilePhotoFile, opts ...grpc.CallOption) (*mtproto.Photo, error)
	// media.getPhoto photo_id:long = Photo;
	MediaGetPhoto(ctx context.Context, in *TLMediaGetPhoto, opts ...grpc.CallOption) (*mtproto.Photo, error)
	// media.getPhotoSizeList size_id:long = PhotoSizeList;
	MediaGetPhotoSizeList(ctx context.Context, in *TLMediaGetPhotoSizeList, opts ...grpc.CallOption) (*PhotoSizeList, error)
	// media.getPhotoSizeListList id_list:Vector<long> = Vector<PhotoSizeList>;
	MediaGetPhotoSizeListList(ctx context.Context, in *TLMediaGetPhotoSizeListList, opts ...grpc.CallOption) (*Vector_PhotoSizeList, error)
	// media.getVideoSizeList size_id:long = VideoSizeList;
	MediaGetVideoSizeList(ctx context.Context, in *TLMediaGetVideoSizeList, opts ...grpc.CallOption) (*VideoSizeList, error)
	// media.uploadedDocumentMedia owner_id:long media:InputMedia = MessageMedia;
	MediaUploadedDocumentMedia(ctx context.Context, in *TLMediaUploadedDocumentMedia, opts ...grpc.CallOption) (*mtproto.MessageMedia, error)
	// media.getDocument id:long = Document;
	MediaGetDocument(ctx context.Context, in *TLMediaGetDocument, opts ...grpc.CallOption) (*mtproto.Document, error)
	// media.getDocumentList id_list:Vector<long> = Vector<Document>;
	MediaGetDocumentList(ctx context.Context, in *TLMediaGetDocumentList, opts ...grpc.CallOption) (*Vector_Document, error)
	// media.uploadEncryptedFile owner_id:long file:InputEncryptedFile = EncryptedFile;
	MediaUploadEncryptedFile(ctx context.Context, in *TLMediaUploadEncryptedFile, opts ...grpc.CallOption) (*mtproto.EncryptedFile, error)
	// media.getEncryptedFile id:long access_hash:long = EncryptedFile;
	MediaGetEncryptedFile(ctx context.Context, in *TLMediaGetEncryptedFile, opts ...grpc.CallOption) (*mtproto.EncryptedFile, error)
	// media.uploadWallPaperFile owner_id:long file:InputFile mime_type:string admin:Bool = Document;
	MediaUploadWallPaperFile(ctx context.Context, in *TLMediaUploadWallPaperFile, opts ...grpc.CallOption) (*mtproto.Document, error)
	// media.uploadThemeFile flags:# owner_id:long file:InputFile thumb:flags.0?InputFile mime_type:string file_name:string = Document;
	MediaUploadThemeFile(ctx context.Context, in *TLMediaUploadThemeFile, opts ...grpc.CallOption) (*mtproto.Document, error)
	// media.uploadStickerFile flags:# owner_id:long file:InputFile thumb:flags.0?InputFile mime_type:string file_name:string document_attribute_sticker:DocumentAttribute = Document;
	MediaUploadStickerFile(ctx context.Context, in *TLMediaUploadStickerFile, opts ...grpc.CallOption) (*mtproto.Document, error)
}

type rPCMediaClient struct {
	cc *grpc.ClientConn
}

func NewRPCMediaClient(cc *grpc.ClientConn) RPCMediaClient {
	return &rPCMediaClient{cc}
}

func (c *rPCMediaClient) MediaUploadPhotoFile(ctx context.Context, in *TLMediaUploadPhotoFile, opts ...grpc.CallOption) (*mtproto.Photo, error) {
	out := new(mtproto.Photo)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_uploadPhotoFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaUploadProfilePhotoFile(ctx context.Context, in *TLMediaUploadProfilePhotoFile, opts ...grpc.CallOption) (*mtproto.Photo, error) {
	out := new(mtproto.Photo)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_uploadProfilePhotoFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaGetPhoto(ctx context.Context, in *TLMediaGetPhoto, opts ...grpc.CallOption) (*mtproto.Photo, error) {
	out := new(mtproto.Photo)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_getPhoto", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaGetPhotoSizeList(ctx context.Context, in *TLMediaGetPhotoSizeList, opts ...grpc.CallOption) (*PhotoSizeList, error) {
	out := new(PhotoSizeList)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_getPhotoSizeList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaGetPhotoSizeListList(ctx context.Context, in *TLMediaGetPhotoSizeListList, opts ...grpc.CallOption) (*Vector_PhotoSizeList, error) {
	out := new(Vector_PhotoSizeList)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_getPhotoSizeListList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaGetVideoSizeList(ctx context.Context, in *TLMediaGetVideoSizeList, opts ...grpc.CallOption) (*VideoSizeList, error) {
	out := new(VideoSizeList)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_getVideoSizeList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaUploadedDocumentMedia(ctx context.Context, in *TLMediaUploadedDocumentMedia, opts ...grpc.CallOption) (*mtproto.MessageMedia, error) {
	out := new(mtproto.MessageMedia)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_uploadedDocumentMedia", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaGetDocument(ctx context.Context, in *TLMediaGetDocument, opts ...grpc.CallOption) (*mtproto.Document, error) {
	out := new(mtproto.Document)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_getDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaGetDocumentList(ctx context.Context, in *TLMediaGetDocumentList, opts ...grpc.CallOption) (*Vector_Document, error) {
	out := new(Vector_Document)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_getDocumentList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaUploadEncryptedFile(ctx context.Context, in *TLMediaUploadEncryptedFile, opts ...grpc.CallOption) (*mtproto.EncryptedFile, error) {
	out := new(mtproto.EncryptedFile)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_uploadEncryptedFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaGetEncryptedFile(ctx context.Context, in *TLMediaGetEncryptedFile, opts ...grpc.CallOption) (*mtproto.EncryptedFile, error) {
	out := new(mtproto.EncryptedFile)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_getEncryptedFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaUploadWallPaperFile(ctx context.Context, in *TLMediaUploadWallPaperFile, opts ...grpc.CallOption) (*mtproto.Document, error) {
	out := new(mtproto.Document)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_uploadWallPaperFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaUploadThemeFile(ctx context.Context, in *TLMediaUploadThemeFile, opts ...grpc.CallOption) (*mtproto.Document, error) {
	out := new(mtproto.Document)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_uploadThemeFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCMediaClient) MediaUploadStickerFile(ctx context.Context, in *TLMediaUploadStickerFile, opts ...grpc.CallOption) (*mtproto.Document, error) {
	out := new(mtproto.Document)
	err := c.cc.Invoke(ctx, "/media.RPCMedia/media_uploadStickerFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RPCMediaServer is the server API for RPCMedia service.
type RPCMediaServer interface {
	// media.uploadPhotoFile flags:# owner_id:long file:InputFile stickers:flags.0?Vector<InputDocument> ttl_seconds:flags.1?int = Photo;
	MediaUploadPhotoFile(context.Context, *TLMediaUploadPhotoFile) (*mtproto.Photo, error)
	// media.uploadProfilePhotoFile flags:# owner_id:long file:flags.0?InputFile video:flags.1?InputFile video_start_ts:flags.2?double = Photo;
	MediaUploadProfilePhotoFile(context.Context, *TLMediaUploadProfilePhotoFile) (*mtproto.Photo, error)
	// media.getPhoto photo_id:long = Photo;
	MediaGetPhoto(context.Context, *TLMediaGetPhoto) (*mtproto.Photo, error)
	// media.getPhotoSizeList size_id:long = PhotoSizeList;
	MediaGetPhotoSizeList(context.Context, *TLMediaGetPhotoSizeList) (*PhotoSizeList, error)
	// media.getPhotoSizeListList id_list:Vector<long> = Vector<PhotoSizeList>;
	MediaGetPhotoSizeListList(context.Context, *TLMediaGetPhotoSizeListList) (*Vector_PhotoSizeList, error)
	// media.getVideoSizeList size_id:long = VideoSizeList;
	MediaGetVideoSizeList(context.Context, *TLMediaGetVideoSizeList) (*VideoSizeList, error)
	// media.uploadedDocumentMedia owner_id:long media:InputMedia = MessageMedia;
	MediaUploadedDocumentMedia(context.Context, *TLMediaUploadedDocumentMedia) (*mtproto.MessageMedia, error)
	// media.getDocument id:long = Document;
	MediaGetDocument(context.Context, *TLMediaGetDocument) (*mtproto.Document, error)
	// media.getDocumentList id_list:Vector<long> = Vector<Document>;
	MediaGetDocumentList(context.Context, *TLMediaGetDocumentList) (*Vector_Document, error)
	// media.uploadEncryptedFile owner_id:long file:InputEncryptedFile = EncryptedFile;
	MediaUploadEncryptedFile(context.Context, *TLMediaUploadEncryptedFile) (*mtproto.EncryptedFile, error)
	// media.getEncryptedFile id:long access_hash:long = EncryptedFile;
	MediaGetEncryptedFile(context.Context, *TLMediaGetEncryptedFile) (*mtproto.EncryptedFile, error)
	// media.uploadWallPaperFile owner_id:long file:InputFile mime_type:string admin:Bool = Document;
	MediaUploadWallPaperFile(context.Context, *TLMediaUploadWallPaperFile) (*mtproto.Document, error)
	// media.uploadThemeFile flags:# owner_id:long file:InputFile thumb:flags.0?InputFile mime_type:string file_name:string = Document;
	MediaUploadThemeFile(context.Context, *TLMediaUploadThemeFile) (*mtproto.Document, error)
	// media.uploadStickerFile flags:# owner_id:long file:InputFile thumb:flags.0?InputFile mime_type:string file_name:string document_attribute_sticker:DocumentAttribute = Document;
	MediaUploadStickerFile(context.Context, *TLMediaUploadStickerFile) (*mtproto.Document, error)
}

// UnimplementedRPCMediaServer can be embedded to have forward compatible implementations.
type UnimplementedRPCMediaServer struct {
}

func (*UnimplementedRPCMediaServer) MediaUploadPhotoFile(ctx context.Context, req *TLMediaUploadPhotoFile) (*mtproto.Photo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaUploadPhotoFile not implemented")
}
func (*UnimplementedRPCMediaServer) MediaUploadProfilePhotoFile(ctx context.Context, req *TLMediaUploadProfilePhotoFile) (*mtproto.Photo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaUploadProfilePhotoFile not implemented")
}
func (*UnimplementedRPCMediaServer) MediaGetPhoto(ctx context.Context, req *TLMediaGetPhoto) (*mtproto.Photo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaGetPhoto not implemented")
}
func (*UnimplementedRPCMediaServer) MediaGetPhotoSizeList(ctx context.Context, req *TLMediaGetPhotoSizeList) (*PhotoSizeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaGetPhotoSizeList not implemented")
}
func (*UnimplementedRPCMediaServer) MediaGetPhotoSizeListList(ctx context.Context, req *TLMediaGetPhotoSizeListList) (*Vector_PhotoSizeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaGetPhotoSizeListList not implemented")
}
func (*UnimplementedRPCMediaServer) MediaGetVideoSizeList(ctx context.Context, req *TLMediaGetVideoSizeList) (*VideoSizeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaGetVideoSizeList not implemented")
}
func (*UnimplementedRPCMediaServer) MediaUploadedDocumentMedia(ctx context.Context, req *TLMediaUploadedDocumentMedia) (*mtproto.MessageMedia, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaUploadedDocumentMedia not implemented")
}
func (*UnimplementedRPCMediaServer) MediaGetDocument(ctx context.Context, req *TLMediaGetDocument) (*mtproto.Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaGetDocument not implemented")
}
func (*UnimplementedRPCMediaServer) MediaGetDocumentList(ctx context.Context, req *TLMediaGetDocumentList) (*Vector_Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaGetDocumentList not implemented")
}
func (*UnimplementedRPCMediaServer) MediaUploadEncryptedFile(ctx context.Context, req *TLMediaUploadEncryptedFile) (*mtproto.EncryptedFile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaUploadEncryptedFile not implemented")
}
func (*UnimplementedRPCMediaServer) MediaGetEncryptedFile(ctx context.Context, req *TLMediaGetEncryptedFile) (*mtproto.EncryptedFile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaGetEncryptedFile not implemented")
}
func (*UnimplementedRPCMediaServer) MediaUploadWallPaperFile(ctx context.Context, req *TLMediaUploadWallPaperFile) (*mtproto.Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaUploadWallPaperFile not implemented")
}
func (*UnimplementedRPCMediaServer) MediaUploadThemeFile(ctx context.Context, req *TLMediaUploadThemeFile) (*mtproto.Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaUploadThemeFile not implemented")
}
func (*UnimplementedRPCMediaServer) MediaUploadStickerFile(ctx context.Context, req *TLMediaUploadStickerFile) (*mtproto.Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MediaUploadStickerFile not implemented")
}

func RegisterRPCMediaServer(s *grpc.Server, srv RPCMediaServer) {
	s.RegisterService(&_RPCMedia_serviceDesc, srv)
}

func _RPCMedia_MediaUploadPhotoFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaUploadPhotoFile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaUploadPhotoFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaUploadPhotoFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaUploadPhotoFile(ctx, req.(*TLMediaUploadPhotoFile))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaUploadProfilePhotoFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaUploadProfilePhotoFile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaUploadProfilePhotoFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaUploadProfilePhotoFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaUploadProfilePhotoFile(ctx, req.(*TLMediaUploadProfilePhotoFile))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaGetPhoto_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaGetPhoto)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaGetPhoto(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaGetPhoto",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaGetPhoto(ctx, req.(*TLMediaGetPhoto))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaGetPhotoSizeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaGetPhotoSizeList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaGetPhotoSizeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaGetPhotoSizeList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaGetPhotoSizeList(ctx, req.(*TLMediaGetPhotoSizeList))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaGetPhotoSizeListList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaGetPhotoSizeListList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaGetPhotoSizeListList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaGetPhotoSizeListList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaGetPhotoSizeListList(ctx, req.(*TLMediaGetPhotoSizeListList))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaGetVideoSizeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaGetVideoSizeList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaGetVideoSizeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaGetVideoSizeList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaGetVideoSizeList(ctx, req.(*TLMediaGetVideoSizeList))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaUploadedDocumentMedia_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaUploadedDocumentMedia)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaUploadedDocumentMedia(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaUploadedDocumentMedia",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaUploadedDocumentMedia(ctx, req.(*TLMediaUploadedDocumentMedia))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaGetDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaGetDocument)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaGetDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaGetDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaGetDocument(ctx, req.(*TLMediaGetDocument))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaGetDocumentList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaGetDocumentList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaGetDocumentList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaGetDocumentList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaGetDocumentList(ctx, req.(*TLMediaGetDocumentList))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaUploadEncryptedFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaUploadEncryptedFile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaUploadEncryptedFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaUploadEncryptedFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaUploadEncryptedFile(ctx, req.(*TLMediaUploadEncryptedFile))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaGetEncryptedFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaGetEncryptedFile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaGetEncryptedFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaGetEncryptedFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaGetEncryptedFile(ctx, req.(*TLMediaGetEncryptedFile))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaUploadWallPaperFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaUploadWallPaperFile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaUploadWallPaperFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaUploadWallPaperFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaUploadWallPaperFile(ctx, req.(*TLMediaUploadWallPaperFile))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaUploadThemeFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaUploadThemeFile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaUploadThemeFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaUploadThemeFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaUploadThemeFile(ctx, req.(*TLMediaUploadThemeFile))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCMedia_MediaUploadStickerFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLMediaUploadStickerFile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCMediaServer).MediaUploadStickerFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/media.RPCMedia/MediaUploadStickerFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCMediaServer).MediaUploadStickerFile(ctx, req.(*TLMediaUploadStickerFile))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPCMedia_serviceDesc = grpc.ServiceDesc{
	ServiceName: "media.RPCMedia",
	HandlerType: (*RPCMediaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "media_uploadPhotoFile",
			Handler:    _RPCMedia_MediaUploadPhotoFile_Handler,
		},
		{
			MethodName: "media_uploadProfilePhotoFile",
			Handler:    _RPCMedia_MediaUploadProfilePhotoFile_Handler,
		},
		{
			MethodName: "media_getPhoto",
			Handler:    _RPCMedia_MediaGetPhoto_Handler,
		},
		{
			MethodName: "media_getPhotoSizeList",
			Handler:    _RPCMedia_MediaGetPhotoSizeList_Handler,
		},
		{
			MethodName: "media_getPhotoSizeListList",
			Handler:    _RPCMedia_MediaGetPhotoSizeListList_Handler,
		},
		{
			MethodName: "media_getVideoSizeList",
			Handler:    _RPCMedia_MediaGetVideoSizeList_Handler,
		},
		{
			MethodName: "media_uploadedDocumentMedia",
			Handler:    _RPCMedia_MediaUploadedDocumentMedia_Handler,
		},
		{
			MethodName: "media_getDocument",
			Handler:    _RPCMedia_MediaGetDocument_Handler,
		},
		{
			MethodName: "media_getDocumentList",
			Handler:    _RPCMedia_MediaGetDocumentList_Handler,
		},
		{
			MethodName: "media_uploadEncryptedFile",
			Handler:    _RPCMedia_MediaUploadEncryptedFile_Handler,
		},
		{
			MethodName: "media_getEncryptedFile",
			Handler:    _RPCMedia_MediaGetEncryptedFile_Handler,
		},
		{
			MethodName: "media_uploadWallPaperFile",
			Handler:    _RPCMedia_MediaUploadWallPaperFile_Handler,
		},
		{
			MethodName: "media_uploadThemeFile",
			Handler:    _RPCMedia_MediaUploadThemeFile_Handler,
		},
		{
			MethodName: "media_uploadStickerFile",
			Handler:    _RPCMedia_MediaUploadStickerFile_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "media.tl.proto",
}

func (m *PhotoSizeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhotoSizeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PhotoSizeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DcId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.DcId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Sizes) > 0 {
		for iNdEx := len(m.Sizes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sizes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMediaTl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.SizeId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.SizeId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintMediaTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLPhotoSizeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLPhotoSizeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLPhotoSizeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VideoSizeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VideoSizeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VideoSizeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DcId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.DcId))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Sizes) > 0 {
		for iNdEx := len(m.Sizes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sizes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMediaTl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.SizeId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.SizeId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintMediaTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLVideoSizeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLVideoSizeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLVideoSizeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaUploadPhotoFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaUploadPhotoFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaUploadPhotoFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TtlSeconds != nil {
		{
			size, err := m.TtlSeconds.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Stickers) > 0 {
		for iNdEx := len(m.Stickers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Stickers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMediaTl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OwnerId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.OwnerId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaUploadProfilePhotoFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaUploadProfilePhotoFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaUploadProfilePhotoFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.VideoStartTs != nil {
		{
			size, err := m.VideoStartTs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Video != nil {
		{
			size, err := m.Video.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OwnerId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.OwnerId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaGetPhoto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaGetPhoto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaGetPhoto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PhotoId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.PhotoId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaGetPhotoSizeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaGetPhotoSizeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaGetPhotoSizeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SizeId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.SizeId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaGetPhotoSizeListList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaGetPhotoSizeListList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaGetPhotoSizeListList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IdList) > 0 {
		dAtA9 := make([]byte, len(m.IdList)*10)
		var j8 int
		for _, num1 := range m.IdList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintMediaTl(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaGetVideoSizeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaGetVideoSizeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaGetVideoSizeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SizeId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.SizeId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaUploadedDocumentMedia) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaUploadedDocumentMedia) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaUploadedDocumentMedia) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Media != nil {
		{
			size, err := m.Media.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OwnerId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.OwnerId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaGetDocument) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaGetDocument) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaGetDocument) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaGetDocumentList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaGetDocumentList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaGetDocumentList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IdList) > 0 {
		dAtA12 := make([]byte, len(m.IdList)*10)
		var j11 int
		for _, num1 := range m.IdList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintMediaTl(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaUploadEncryptedFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaUploadEncryptedFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaUploadEncryptedFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OwnerId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.OwnerId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaGetEncryptedFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaGetEncryptedFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaGetEncryptedFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AccessHash != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.AccessHash))
		i--
		dAtA[i] = 0x20
	}
	if m.Id != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaUploadWallPaperFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaUploadWallPaperFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaUploadWallPaperFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Admin != nil {
		{
			size, err := m.Admin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.MimeType) > 0 {
		i -= len(m.MimeType)
		copy(dAtA[i:], m.MimeType)
		i = encodeVarintMediaTl(dAtA, i, uint64(len(m.MimeType)))
		i--
		dAtA[i] = 0x2a
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OwnerId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.OwnerId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaUploadThemeFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaUploadThemeFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaUploadThemeFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintMediaTl(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.MimeType) > 0 {
		i -= len(m.MimeType)
		copy(dAtA[i:], m.MimeType)
		i = encodeVarintMediaTl(dAtA, i, uint64(len(m.MimeType)))
		i--
		dAtA[i] = 0x32
	}
	if m.Thumb != nil {
		{
			size, err := m.Thumb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OwnerId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.OwnerId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMediaUploadStickerFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMediaUploadStickerFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMediaUploadStickerFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DocumentAttributeSticker != nil {
		{
			size, err := m.DocumentAttributeSticker.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintMediaTl(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.MimeType) > 0 {
		i -= len(m.MimeType)
		copy(dAtA[i:], m.MimeType)
		i = encodeVarintMediaTl(dAtA, i, uint64(len(m.MimeType)))
		i--
		dAtA[i] = 0x32
	}
	if m.Thumb != nil {
		{
			size, err := m.Thumb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.OwnerId != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.OwnerId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintMediaTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Vector_PhotoSizeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vector_PhotoSizeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vector_PhotoSizeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Datas) > 0 {
		for iNdEx := len(m.Datas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Datas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMediaTl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Vector_Document) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vector_Document) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vector_Document) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Datas) > 0 {
		for iNdEx := len(m.Datas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Datas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMediaTl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintMediaTl(dAtA []byte, offset int, v uint64) int {
	offset -= sovMediaTl(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *PhotoSizeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.SizeId != 0 {
		n += 1 + sovMediaTl(uint64(m.SizeId))
	}
	if len(m.Sizes) > 0 {
		for _, e := range m.Sizes {
			l = e.Size()
			n += 1 + l + sovMediaTl(uint64(l))
		}
	}
	if m.DcId != 0 {
		n += 1 + sovMediaTl(uint64(m.DcId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLPhotoSizeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VideoSizeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.SizeId != 0 {
		n += 1 + sovMediaTl(uint64(m.SizeId))
	}
	if len(m.Sizes) > 0 {
		for _, e := range m.Sizes {
			l = e.Size()
			n += 1 + l + sovMediaTl(uint64(l))
		}
	}
	if m.DcId != 0 {
		n += 1 + sovMediaTl(uint64(m.DcId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLVideoSizeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaUploadPhotoFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.OwnerId != 0 {
		n += 1 + sovMediaTl(uint64(m.OwnerId))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if len(m.Stickers) > 0 {
		for _, e := range m.Stickers {
			l = e.Size()
			n += 1 + l + sovMediaTl(uint64(l))
		}
	}
	if m.TtlSeconds != nil {
		l = m.TtlSeconds.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaUploadProfilePhotoFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.OwnerId != 0 {
		n += 1 + sovMediaTl(uint64(m.OwnerId))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.Video != nil {
		l = m.Video.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.VideoStartTs != nil {
		l = m.VideoStartTs.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaGetPhoto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.PhotoId != 0 {
		n += 1 + sovMediaTl(uint64(m.PhotoId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaGetPhotoSizeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.SizeId != 0 {
		n += 1 + sovMediaTl(uint64(m.SizeId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaGetPhotoSizeListList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if len(m.IdList) > 0 {
		l = 0
		for _, e := range m.IdList {
			l += sovMediaTl(uint64(e))
		}
		n += 1 + sovMediaTl(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaGetVideoSizeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.SizeId != 0 {
		n += 1 + sovMediaTl(uint64(m.SizeId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaUploadedDocumentMedia) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.OwnerId != 0 {
		n += 1 + sovMediaTl(uint64(m.OwnerId))
	}
	if m.Media != nil {
		l = m.Media.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaGetDocument) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.Id != 0 {
		n += 1 + sovMediaTl(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaGetDocumentList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if len(m.IdList) > 0 {
		l = 0
		for _, e := range m.IdList {
			l += sovMediaTl(uint64(e))
		}
		n += 1 + sovMediaTl(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaUploadEncryptedFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.OwnerId != 0 {
		n += 1 + sovMediaTl(uint64(m.OwnerId))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaGetEncryptedFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.Id != 0 {
		n += 1 + sovMediaTl(uint64(m.Id))
	}
	if m.AccessHash != 0 {
		n += 1 + sovMediaTl(uint64(m.AccessHash))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaUploadWallPaperFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.OwnerId != 0 {
		n += 1 + sovMediaTl(uint64(m.OwnerId))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.Admin != nil {
		l = m.Admin.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaUploadThemeFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.OwnerId != 0 {
		n += 1 + sovMediaTl(uint64(m.OwnerId))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.Thumb != nil {
		l = m.Thumb.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovMediaTl(uint64(l))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLMediaUploadStickerFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovMediaTl(uint64(m.Constructor))
	}
	if m.OwnerId != 0 {
		n += 1 + sovMediaTl(uint64(m.OwnerId))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.Thumb != nil {
		l = m.Thumb.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovMediaTl(uint64(l))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.DocumentAttributeSticker != nil {
		l = m.DocumentAttributeSticker.Size()
		n += 1 + l + sovMediaTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Vector_PhotoSizeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Datas) > 0 {
		for _, e := range m.Datas {
			l = e.Size()
			n += 1 + l + sovMediaTl(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Vector_Document) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Datas) > 0 {
		for _, e := range m.Datas {
			l = e.Size()
			n += 1 + l + sovMediaTl(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMediaTl(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMediaTl(x uint64) (n int) {
	return sovMediaTl(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *PhotoSizeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhotoSizeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhotoSizeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeId", wireType)
			}
			m.SizeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sizes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sizes = append(m.Sizes, &mtproto.PhotoSize{})
			if err := m.Sizes[len(m.Sizes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcId", wireType)
			}
			m.DcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DcId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLPhotoSizeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_photoSizeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_photoSizeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &PhotoSizeList{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VideoSizeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VideoSizeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VideoSizeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeId", wireType)
			}
			m.SizeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sizes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sizes = append(m.Sizes, &mtproto.VideoSize{})
			if err := m.Sizes[len(m.Sizes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcId", wireType)
			}
			m.DcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DcId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLVideoSizeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_videoSizeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_videoSizeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &VideoSizeList{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaUploadPhotoFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_uploadPhotoFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_uploadPhotoFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &mtproto.InputFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stickers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stickers = append(m.Stickers, &mtproto.InputDocument{})
			if err := m.Stickers[len(m.Stickers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TtlSeconds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TtlSeconds == nil {
				m.TtlSeconds = &types.Int32Value{}
			}
			if err := m.TtlSeconds.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaUploadProfilePhotoFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_uploadProfilePhotoFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_uploadProfilePhotoFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &mtproto.InputFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Video", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Video == nil {
				m.Video = &mtproto.InputFile{}
			}
			if err := m.Video.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoStartTs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VideoStartTs == nil {
				m.VideoStartTs = &types.DoubleValue{}
			}
			if err := m.VideoStartTs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaGetPhoto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_getPhoto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_getPhoto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoId", wireType)
			}
			m.PhotoId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhotoId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaGetPhotoSizeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_getPhotoSizeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_getPhotoSizeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeId", wireType)
			}
			m.SizeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaGetPhotoSizeListList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_getPhotoSizeListList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_getPhotoSizeListList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMediaTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IdList = append(m.IdList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMediaTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMediaTl
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMediaTl
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IdList) == 0 {
					m.IdList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMediaTl
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IdList = append(m.IdList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IdList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaGetVideoSizeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_getVideoSizeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_getVideoSizeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeId", wireType)
			}
			m.SizeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaUploadedDocumentMedia) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_uploadedDocumentMedia: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_uploadedDocumentMedia: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Media == nil {
				m.Media = &mtproto.InputMedia{}
			}
			if err := m.Media.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaGetDocument) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_getDocument: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_getDocument: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaGetDocumentList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_getDocumentList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_getDocumentList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMediaTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IdList = append(m.IdList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMediaTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMediaTl
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMediaTl
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IdList) == 0 {
					m.IdList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMediaTl
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IdList = append(m.IdList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IdList", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaUploadEncryptedFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_uploadEncryptedFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_uploadEncryptedFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &mtproto.InputEncryptedFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaGetEncryptedFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_getEncryptedFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_getEncryptedFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaUploadWallPaperFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_uploadWallPaperFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_uploadWallPaperFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &mtproto.InputFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Admin == nil {
				m.Admin = &mtproto.Bool{}
			}
			if err := m.Admin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaUploadThemeFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_uploadThemeFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_uploadThemeFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &mtproto.InputFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumb == nil {
				m.Thumb = &mtproto.InputFile{}
			}
			if err := m.Thumb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMediaUploadStickerFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_media_uploadStickerFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_media_uploadStickerFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerId", wireType)
			}
			m.OwnerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &mtproto.InputFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Thumb == nil {
				m.Thumb = &mtproto.InputFile{}
			}
			if err := m.Thumb.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentAttributeSticker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DocumentAttributeSticker == nil {
				m.DocumentAttributeSticker = &mtproto.DocumentAttribute{}
			}
			if err := m.DocumentAttributeSticker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vector_PhotoSizeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vector_PhotoSizeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vector_PhotoSizeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datas = append(m.Datas, &PhotoSizeList{})
			if err := m.Datas[len(m.Datas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vector_Document) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vector_Document: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vector_Document: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datas = append(m.Datas, &mtproto.Document{})
			if err := m.Datas[len(m.Datas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMediaTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMediaTl(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMediaTl
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMediaTl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMediaTl
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMediaTl
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMediaTl
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMediaTl        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMediaTl          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMediaTl = fmt.Errorf("proto: unexpected end of group")
)
