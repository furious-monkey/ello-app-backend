// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: inbox.tl.proto

package inbox

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	mtproto "github.com/teamgram/proto/mtproto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TLConstructor int32

const (
	CRC32_UNKNOWN                           TLConstructor = 0
	CRC32_inboxMessageData                  TLConstructor = 1002286548
	CRC32_inbox_sendUserMessageToInbox      TLConstructor = -208741709
	CRC32_inbox_sendChatMessageToInbox      TLConstructor = -1760197438
	CRC32_inbox_sendUserMultiMessageToInbox TLConstructor = -1782288007
	CRC32_inbox_sendChatMultiMessageToInbox TLConstructor = -694455924
	CRC32_inbox_editUserMessageToInbox      TLConstructor = 1559967656
	CRC32_inbox_editChatMessageToInbox      TLConstructor = 2031122959
	CRC32_inbox_deleteMessagesToInbox       TLConstructor = 1529778436
	CRC32_inbox_deleteUserHistoryToInbox    TLConstructor = 336232792
	CRC32_inbox_deleteChatHistoryToInbox    TLConstructor = -659905022
	CRC32_inbox_readUserMediaUnreadToInbox  TLConstructor = 1096756266
	CRC32_inbox_readChatMediaUnreadToInbox  TLConstructor = 1800413425
	CRC32_inbox_updateHistoryReaded         TLConstructor = -1010283296
	CRC32_inbox_updatePinnedMessage         TLConstructor = -1452528908
	CRC32_inbox_unpinAllMessages            TLConstructor = 589079137
)

var TLConstructor_name = map[int32]string{
	0:           "CRC32_UNKNOWN",
	1002286548:  "CRC32_inboxMessageData",
	-208741709:  "CRC32_inbox_sendUserMessageToInbox",
	-1760197438: "CRC32_inbox_sendChatMessageToInbox",
	-1782288007: "CRC32_inbox_sendUserMultiMessageToInbox",
	-694455924:  "CRC32_inbox_sendChatMultiMessageToInbox",
	1559967656:  "CRC32_inbox_editUserMessageToInbox",
	2031122959:  "CRC32_inbox_editChatMessageToInbox",
	1529778436:  "CRC32_inbox_deleteMessagesToInbox",
	336232792:   "CRC32_inbox_deleteUserHistoryToInbox",
	-659905022:  "CRC32_inbox_deleteChatHistoryToInbox",
	1096756266:  "CRC32_inbox_readUserMediaUnreadToInbox",
	1800413425:  "CRC32_inbox_readChatMediaUnreadToInbox",
	-1010283296: "CRC32_inbox_updateHistoryReaded",
	-1452528908: "CRC32_inbox_updatePinnedMessage",
	589079137:   "CRC32_inbox_unpinAllMessages",
}

var TLConstructor_value = map[string]int32{
	"CRC32_UNKNOWN":                           0,
	"CRC32_inboxMessageData":                  1002286548,
	"CRC32_inbox_sendUserMessageToInbox":      -208741709,
	"CRC32_inbox_sendChatMessageToInbox":      -1760197438,
	"CRC32_inbox_sendUserMultiMessageToInbox": -1782288007,
	"CRC32_inbox_sendChatMultiMessageToInbox": -694455924,
	"CRC32_inbox_editUserMessageToInbox":      1559967656,
	"CRC32_inbox_editChatMessageToInbox":      2031122959,
	"CRC32_inbox_deleteMessagesToInbox":       1529778436,
	"CRC32_inbox_deleteUserHistoryToInbox":    336232792,
	"CRC32_inbox_deleteChatHistoryToInbox":    -659905022,
	"CRC32_inbox_readUserMediaUnreadToInbox":  1096756266,
	"CRC32_inbox_readChatMediaUnreadToInbox":  1800413425,
	"CRC32_inbox_updateHistoryReaded":         -1010283296,
	"CRC32_inbox_updatePinnedMessage":         -1452528908,
	"CRC32_inbox_unpinAllMessages":            589079137,
}

func (x TLConstructor) String() string {
	return proto.EnumName(TLConstructor_name, int32(x))
}

func (TLConstructor) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9a6f35d665e824e1, []int{0}
}

//--------------------------------------------------------------------------------------------
// inboxMessageData random_id:long dialog_message_id:long message:Message = InboxMessageData;
//
// InboxMessageData <--
//  + TL_inboxMessageData
//
type InboxMessageData struct {
	PredicateName        string           `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor    `protobuf:"varint,2,opt,name=constructor,proto3,enum=inbox.TLConstructor" json:"constructor,omitempty"`
	RandomId             int64            `protobuf:"varint,3,opt,name=random_id,json=randomId,proto3" json:"random_id,omitempty"`
	DialogMessageId      int64            `protobuf:"varint,4,opt,name=dialog_message_id,json=dialogMessageId,proto3" json:"dialog_message_id,omitempty"`
	Message              *mtproto.Message `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *InboxMessageData) Reset()         { *m = InboxMessageData{} }
func (m *InboxMessageData) String() string { return proto.CompactTextString(m) }
func (*InboxMessageData) ProtoMessage()    {}
func (*InboxMessageData) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a6f35d665e824e1, []int{0}
}
func (m *InboxMessageData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InboxMessageData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InboxMessageData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InboxMessageData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InboxMessageData.Merge(m, src)
}
func (m *InboxMessageData) XXX_Size() int {
	return m.Size()
}
func (m *InboxMessageData) XXX_DiscardUnknown() {
	xxx_messageInfo_InboxMessageData.DiscardUnknown(m)
}

var xxx_messageInfo_InboxMessageData proto.InternalMessageInfo

func (m *InboxMessageData) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *InboxMessageData) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *InboxMessageData) GetRandomId() int64 {
	if m != nil {
		return m.RandomId
	}
	return 0
}

func (m *InboxMessageData) GetDialogMessageId() int64 {
	if m != nil {
		return m.DialogMessageId
	}
	return 0
}

func (m *InboxMessageData) GetMessage() *mtproto.Message {
	if m != nil {
		return m.Message
	}
	return nil
}

// inboxMessageData random_id:long dialog_message_id:long message:Message = InboxMessageData;
type TLInboxMessageData struct {
	Data2                *InboxMessageData `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TLInboxMessageData) Reset()         { *m = TLInboxMessageData{} }
func (m *TLInboxMessageData) String() string { return proto.CompactTextString(m) }
func (*TLInboxMessageData) ProtoMessage()    {}
func (*TLInboxMessageData) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a6f35d665e824e1, []int{1}
}
func (m *TLInboxMessageData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLInboxMessageData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLInboxMessageData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLInboxMessageData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLInboxMessageData.Merge(m, src)
}
func (m *TLInboxMessageData) XXX_Size() int {
	return m.Size()
}
func (m *TLInboxMessageData) XXX_DiscardUnknown() {
	xxx_messageInfo_TLInboxMessageData.DiscardUnknown(m)
}

var xxx_messageInfo_TLInboxMessageData proto.InternalMessageInfo

func (m *TLInboxMessageData) GetData2() *InboxMessageData {
	if m != nil {
		return m.Data2
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// inbox.sendUserMessageToInbox from_id:long peer_user_id:long message:InboxMessageData = Void;
type TLInboxSendUserMessageToInbox struct {
	Constructor          TLConstructor     `protobuf:"varint,1,opt,name=constructor,proto3,enum=inbox.TLConstructor" json:"constructor,omitempty"`
	FromId               int64             `protobuf:"varint,3,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	PeerUserId           int64             `protobuf:"varint,4,opt,name=peer_user_id,json=peerUserId,proto3" json:"peer_user_id,omitempty"`
	Message              *InboxMessageData `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TLInboxSendUserMessageToInbox) Reset()         { *m = TLInboxSendUserMessageToInbox{} }
func (m *TLInboxSendUserMessageToInbox) String() string { return proto.CompactTextString(m) }
func (*TLInboxSendUserMessageToInbox) ProtoMessage()    {}
func (*TLInboxSendUserMessageToInbox) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a6f35d665e824e1, []int{2}
}
func (m *TLInboxSendUserMessageToInbox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLInboxSendUserMessageToInbox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLInboxSendUserMessageToInbox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLInboxSendUserMessageToInbox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLInboxSendUserMessageToInbox.Merge(m, src)
}
func (m *TLInboxSendUserMessageToInbox) XXX_Size() int {
	return m.Size()
}
func (m *TLInboxSendUserMessageToInbox) XXX_DiscardUnknown() {
	xxx_messageInfo_TLInboxSendUserMessageToInbox.DiscardUnknown(m)
}

var xxx_messageInfo_TLInboxSendUserMessageToInbox proto.InternalMessageInfo

func (m *TLInboxSendUserMessageToInbox) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLInboxSendUserMessageToInbox) GetFromId() int64 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *TLInboxSendUserMessageToInbox) GetPeerUserId() int64 {
	if m != nil {
		return m.PeerUserId
	}
	return 0
}

func (m *TLInboxSendUserMessageToInbox) GetMessage() *InboxMessageData {
	if m != nil {
		return m.Message
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// inbox.sendChatMessageToInbox from_id:long peer_chat_id:long message:InboxMessageData = Void;
type TLInboxSendChatMessageToInbox struct {
	Constructor          TLConstructor     `protobuf:"varint,1,opt,name=constructor,proto3,enum=inbox.TLConstructor" json:"constructor,omitempty"`
	FromId               int64             `protobuf:"varint,3,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	PeerChatId           int64             `protobuf:"varint,4,opt,name=peer_chat_id,json=peerChatId,proto3" json:"peer_chat_id,omitempty"`
	Message              *InboxMessageData `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TLInboxSendChatMessageToInbox) Reset()         { *m = TLInboxSendChatMessageToInbox{} }
func (m *TLInboxSendChatMessageToInbox) String() string { return proto.CompactTextString(m) }
func (*TLInboxSendChatMessageToInbox) ProtoMessage()    {}
func (*TLInboxSendChatMessageToInbox) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a6f35d665e824e1, []int{3}
}
func (m *TLInboxSendChatMessageToInbox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLInboxSendChatMessageToInbox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLInboxSendChatMessageToInbox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLInboxSendChatMessageToInbox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLInboxSendChatMessageToInbox.Merge(m, src)
}
func (m *TLInboxSendChatMessageToInbox) XXX_Size() int {
	return m.Size()
}
func (m *TLInboxSendChatMessageToInbox) XXX_DiscardUnknown() {
	xxx_messageInfo_TLInboxSendChatMessageToInbox.DiscardUnknown(m)
}

var xxx_messageInfo_TLInboxSendChatMessageToInbox proto.InternalMessageInfo

func (m *TLInboxSendChatMessageToInbox) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLInboxSendChatMessageToInbox) GetFromId() int64 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *TLInboxSendChatMessageToInbox) GetPeerChatId() int64 {
	if m != nil {
		return m.PeerChatId
	}
	return 0
}

func (m *TLInboxSendChatMessageToInbox) GetMessage() *InboxMessageData {
	if m != nil {
		return m.Message
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// inbox.sendUserMultiMessageToInbox from_id:long peer_user_id:long message:Vector<InboxMessageData> = Void;
type TLInboxSendUserMultiMessageToInbox struct {
	Constructor          TLConstructor       `protobuf:"varint,1,opt,name=constructor,proto3,enum=inbox.TLConstructor" json:"constructor,omitempty"`
	FromId               int64               `protobuf:"varint,3,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	PeerUserId           int64               `protobuf:"varint,4,opt,name=peer_user_id,json=peerUserId,proto3" json:"peer_user_id,omitempty"`
	Message              []*InboxMessageData `protobuf:"bytes,5,rep,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TLInboxSendUserMultiMessageToInbox) Reset()         { *m = TLInboxSendUserMultiMessageToInbox{} }
func (m *TLInboxSendUserMultiMessageToInbox) String() string { return proto.CompactTextString(m) }
func (*TLInboxSendUserMultiMessageToInbox) ProtoMessage()    {}
func (*TLInboxSendUserMultiMessageToInbox) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a6f35d665e824e1, []int{4}
}
func (m *TLInboxSendUserMultiMessageToInbox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLInboxSendUserMultiMessageToInbox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLInboxSendUserMultiMessageToInbox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLInboxSendUserMultiMessageToInbox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLInboxSendUserMultiMessageToInbox.Merge(m, src)
}
func (m *TLInboxSendUserMultiMessageToInbox) XXX_Size() int {
	return m.Size()
}
func (m *TLInboxSendUserMultiMessageToInbox) XXX_DiscardUnknown() {
	xxx_messageInfo_TLInboxSendUserMultiMessageToInbox.DiscardUnknown(m)
}

var xxx_messageInfo_TLInboxSendUserMultiMessageToInbox proto.InternalMessageInfo

func (m *TLInboxSendUserMultiMessageToInbox) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLInboxSendUserMultiMessageToInbox) GetFromId() int64 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *TLInboxSendUserMultiMessageToInbox) GetPeerUserId() int64 {
	if m != nil {
		return m.PeerUserId
	}
	return 0
}

func (m *TLInboxSendUserMultiMessageToInbox) GetMessage() []*InboxMessageData {
	if m != nil {
		return m.Message
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// inbox.sendChatMultiMessageToInbox from_id:long peer_chat_id:long message:Vector<InboxMessageData> = Void;
type TLInboxSendChatMultiMessageToInbox struct {
	Constructor          TLConstructor       `protobuf:"varint,1,opt,name=constructor,proto3,enum=inbox.TLConstructor" json:"constructor,omitempty"`
	FromId               int64               `protobuf:"varint,3,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	PeerChatId           int64               `protobuf:"varint,4,opt,name=peer_chat_id,json=peerChatId,proto3" json:"peer_chat_id,omitempty"`
	Message              []*InboxMessageData `protobuf:"bytes,5,rep,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *TLInboxSendChatMultiMessageToInbox) Reset()         { *m = TLInboxSendChatMultiMessageToInbox{} }
func (m *TLInboxSendChatMultiMessageToInbox) String() string { return proto.CompactTextString(m) }
func (*TLInboxSendChatMultiMessageToInbox) ProtoMessage()    {}
func (*TLInboxSendChatMultiMessageToInbox) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a6f35d665e824e1, []int{5}
}
func (m *TLInboxSendChatMultiMessageToInbox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLInboxSendChatMultiMessageToInbox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLInboxSendChatMultiMessageToInbox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLInboxSendChatMultiMessageToInbox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLInboxSendChatMultiMessageToInbox.Merge(m, src)
}
func (m *TLInboxSendChatMultiMessageToInbox) XXX_Size() int {
	return m.Size()
}
func (m *TLInboxSendChatMultiMessageToInbox) XXX_DiscardUnknown() {
	xxx_messageInfo_TLInboxSendChatMultiMessageToInbox.DiscardUnknown(m)
}

var xxx_messageInfo_TLInboxSendChatMultiMessageToInbox proto.InternalMessageInfo

func (m *TLInboxSendChatMultiMessageToInbox) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLInboxSendChatMultiMessageToInbox) GetFromId() int64 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *TLInboxSendChatMultiMessageToInbox) GetPeerChatId() int64 {
	if m != nil {
		return m.PeerChatId
	}
	return 0
}

func (m *TLInboxSendChatMultiMessageToInbox) GetMessage() []*InboxMessageData {
	if m != nil {
		return m.Message
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// inbox.editUserMessageToInbox from_id:long peer_user_id:long message:Message = Void;
type TLInboxEditUserMessageToInbox struct {
	Constructor          TLConstructor    `protobuf:"varint,1,opt,name=constructor,proto3,enum=inbox.TLConstructor" json:"constructor,omitempty"`
	FromId               int64            `protobuf:"varint,3,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	PeerUserId           int64            `protobuf:"varint,4,opt,name=peer_user_id,json=peerUserId,proto3" json:"peer_user_id,omitempty"`
	Message              *mtproto.Message `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TLInboxEditUserMessageToInbox) Reset()         { *m = TLInboxEditUserMessageToInbox{} }
func (m *TLInboxEditUserMessageToInbox) String() string { return proto.CompactTextString(m) }
func (*TLInboxEditUserMessageToInbox) ProtoMessage()    {}
func (*TLInboxEditUserMessageToInbox) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a6f35d665e824e1, []int{6}
}
func (m *TLInboxEditUserMessageToInbox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLInboxEditUserMessageToInbox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLInboxEditUserMessageToInbox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLInboxEditUserMessageToInbox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLInboxEditUserMessageToInbox.Merge(m, src)
}
func (m *TLInboxEditUserMessageToInbox) XXX_Size() int {
	return m.Size()
}
func (m *TLInboxEditUserMessageToInbox) XXX_DiscardUnknown() {
	xxx_messageInfo_TLInboxEditUserMessageToInbox.DiscardUnknown(m)
}

var xxx_messageInfo_TLInboxEditUserMessageToInbox proto.InternalMessageInfo

func (m *TLInboxEditUserMessageToInbox) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLInboxEditUserMessageToInbox) GetFromId() int64 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *TLInboxEditUserMessageToInbox) GetPeerUserId() int64 {
	if m != nil {
		return m.PeerUserId
	}
	return 0
}

func (m *TLInboxEditUserMessageToInbox) GetMessage() *mtproto.Message {
	if m != nil {
		return m.Message
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// inbox.editChatMessageToInbox from_id:long peer_chat_id:long message:Message = Void;
type TLInboxEditChatMessageToInbox struct {
	Constructor          TLConstructor    `protobuf:"varint,1,opt,name=constructor,proto3,enum=inbox.TLConstructor" json:"constructor,omitempty"`
	FromId               int64            `protobuf:"varint,3,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	PeerChatId           int64            `protobuf:"varint,4,opt,name=peer_chat_id,json=peerChatId,proto3" json:"peer_chat_id,omitempty"`
	Message              *mtproto.Message `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TLInboxEditChatMessageToInbox) Reset()         { *m = TLInboxEditChatMessageToInbox{} }
func (m *TLInboxEditChatMessageToInbox) String() string { return proto.CompactTextString(m) }
func (*TLInboxEditChatMessageToInbox) ProtoMessage()    {}
func (*TLInboxEditChatMessageToInbox) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a6f35d665e824e1, []int{7}
}
func (m *TLInboxEditChatMessageToInbox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLInboxEditChatMessageToInbox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLInboxEditChatMessageToInbox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLInboxEditChatMessageToInbox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLInboxEditChatMessageToInbox.Merge(m, src)
}
func (m *TLInboxEditChatMessageToInbox) XXX_Size() int {
	return m.Size()
}
func (m *TLInboxEditChatMessageToInbox) XXX_DiscardUnknown() {
	xxx_messageInfo_TLInboxEditChatMessageToInbox.DiscardUnknown(m)
}

var xxx_messageInfo_TLInboxEditChatMessageToInbox proto.InternalMessageInfo

func (m *TLInboxEditChatMessageToInbox) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLInboxEditChatMessageToInbox) GetFromId() int64 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *TLInboxEditChatMessageToInbox) GetPeerChatId() int64 {
	if m != nil {
		return m.PeerChatId
	}
	return 0
}

func (m *TLInboxEditChatMessageToInbox) GetMessage() *mtproto.Message {
	if m != nil {
		return m.Message
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// inbox.deleteMessagesToInbox from_id:long id:Vector<long> = Void;
type TLInboxDeleteMessagesToInbox struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=inbox.TLConstructor" json:"constructor,omitempty"`
	FromId               int64         `protobuf:"varint,3,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	Id                   []int64       `protobuf:"varint,4,rep,packed,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLInboxDeleteMessagesToInbox) Reset()         { *m = TLInboxDeleteMessagesToInbox{} }
func (m *TLInboxDeleteMessagesToInbox) String() string { return proto.CompactTextString(m) }
func (*TLInboxDeleteMessagesToInbox) ProtoMessage()    {}
func (*TLInboxDeleteMessagesToInbox) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a6f35d665e824e1, []int{8}
}
func (m *TLInboxDeleteMessagesToInbox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLInboxDeleteMessagesToInbox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLInboxDeleteMessagesToInbox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLInboxDeleteMessagesToInbox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLInboxDeleteMessagesToInbox.Merge(m, src)
}
func (m *TLInboxDeleteMessagesToInbox) XXX_Size() int {
	return m.Size()
}
func (m *TLInboxDeleteMessagesToInbox) XXX_DiscardUnknown() {
	xxx_messageInfo_TLInboxDeleteMessagesToInbox.DiscardUnknown(m)
}

var xxx_messageInfo_TLInboxDeleteMessagesToInbox proto.InternalMessageInfo

func (m *TLInboxDeleteMessagesToInbox) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLInboxDeleteMessagesToInbox) GetFromId() int64 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *TLInboxDeleteMessagesToInbox) GetId() []int64 {
	if m != nil {
		return m.Id
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// inbox.deleteUserHistoryToInbox flags:# from_id:long peer_user_id:long just_clear:flags.1?true max_id:int = Void;
type TLInboxDeleteUserHistoryToInbox struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=inbox.TLConstructor" json:"constructor,omitempty"`
	FromId               int64         `protobuf:"varint,3,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	PeerUserId           int64         `protobuf:"varint,4,opt,name=peer_user_id,json=peerUserId,proto3" json:"peer_user_id,omitempty"`
	JustClear            bool          `protobuf:"varint,5,opt,name=just_clear,json=justClear,proto3" json:"just_clear,omitempty"`
	MaxId                int32         `protobuf:"varint,6,opt,name=max_id,json=maxId,proto3" json:"max_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLInboxDeleteUserHistoryToInbox) Reset()         { *m = TLInboxDeleteUserHistoryToInbox{} }
func (m *TLInboxDeleteUserHistoryToInbox) String() string { return proto.CompactTextString(m) }
func (*TLInboxDeleteUserHistoryToInbox) ProtoMessage()    {}
func (*TLInboxDeleteUserHistoryToInbox) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a6f35d665e824e1, []int{9}
}
func (m *TLInboxDeleteUserHistoryToInbox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLInboxDeleteUserHistoryToInbox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLInboxDeleteUserHistoryToInbox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLInboxDeleteUserHistoryToInbox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLInboxDeleteUserHistoryToInbox.Merge(m, src)
}
func (m *TLInboxDeleteUserHistoryToInbox) XXX_Size() int {
	return m.Size()
}
func (m *TLInboxDeleteUserHistoryToInbox) XXX_DiscardUnknown() {
	xxx_messageInfo_TLInboxDeleteUserHistoryToInbox.DiscardUnknown(m)
}

var xxx_messageInfo_TLInboxDeleteUserHistoryToInbox proto.InternalMessageInfo

func (m *TLInboxDeleteUserHistoryToInbox) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLInboxDeleteUserHistoryToInbox) GetFromId() int64 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *TLInboxDeleteUserHistoryToInbox) GetPeerUserId() int64 {
	if m != nil {
		return m.PeerUserId
	}
	return 0
}

func (m *TLInboxDeleteUserHistoryToInbox) GetJustClear() bool {
	if m != nil {
		return m.JustClear
	}
	return false
}

func (m *TLInboxDeleteUserHistoryToInbox) GetMaxId() int32 {
	if m != nil {
		return m.MaxId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// inbox.deleteChatHistoryToInbox from_id:long peer_chat_id:long max_id:int = Void;
type TLInboxDeleteChatHistoryToInbox struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=inbox.TLConstructor" json:"constructor,omitempty"`
	FromId               int64         `protobuf:"varint,3,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	PeerChatId           int64         `protobuf:"varint,4,opt,name=peer_chat_id,json=peerChatId,proto3" json:"peer_chat_id,omitempty"`
	MaxId                int32         `protobuf:"varint,5,opt,name=max_id,json=maxId,proto3" json:"max_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLInboxDeleteChatHistoryToInbox) Reset()         { *m = TLInboxDeleteChatHistoryToInbox{} }
func (m *TLInboxDeleteChatHistoryToInbox) String() string { return proto.CompactTextString(m) }
func (*TLInboxDeleteChatHistoryToInbox) ProtoMessage()    {}
func (*TLInboxDeleteChatHistoryToInbox) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a6f35d665e824e1, []int{10}
}
func (m *TLInboxDeleteChatHistoryToInbox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLInboxDeleteChatHistoryToInbox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLInboxDeleteChatHistoryToInbox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLInboxDeleteChatHistoryToInbox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLInboxDeleteChatHistoryToInbox.Merge(m, src)
}
func (m *TLInboxDeleteChatHistoryToInbox) XXX_Size() int {
	return m.Size()
}
func (m *TLInboxDeleteChatHistoryToInbox) XXX_DiscardUnknown() {
	xxx_messageInfo_TLInboxDeleteChatHistoryToInbox.DiscardUnknown(m)
}

var xxx_messageInfo_TLInboxDeleteChatHistoryToInbox proto.InternalMessageInfo

func (m *TLInboxDeleteChatHistoryToInbox) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLInboxDeleteChatHistoryToInbox) GetFromId() int64 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *TLInboxDeleteChatHistoryToInbox) GetPeerChatId() int64 {
	if m != nil {
		return m.PeerChatId
	}
	return 0
}

func (m *TLInboxDeleteChatHistoryToInbox) GetMaxId() int32 {
	if m != nil {
		return m.MaxId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// inbox.readUserMediaUnreadToInbox from_id:long id:Vector<int> = Void;
type TLInboxReadUserMediaUnreadToInbox struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=inbox.TLConstructor" json:"constructor,omitempty"`
	FromId               int64         `protobuf:"varint,3,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	Id                   []int32       `protobuf:"varint,4,rep,packed,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLInboxReadUserMediaUnreadToInbox) Reset()         { *m = TLInboxReadUserMediaUnreadToInbox{} }
func (m *TLInboxReadUserMediaUnreadToInbox) String() string { return proto.CompactTextString(m) }
func (*TLInboxReadUserMediaUnreadToInbox) ProtoMessage()    {}
func (*TLInboxReadUserMediaUnreadToInbox) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a6f35d665e824e1, []int{11}
}
func (m *TLInboxReadUserMediaUnreadToInbox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLInboxReadUserMediaUnreadToInbox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLInboxReadUserMediaUnreadToInbox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLInboxReadUserMediaUnreadToInbox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLInboxReadUserMediaUnreadToInbox.Merge(m, src)
}
func (m *TLInboxReadUserMediaUnreadToInbox) XXX_Size() int {
	return m.Size()
}
func (m *TLInboxReadUserMediaUnreadToInbox) XXX_DiscardUnknown() {
	xxx_messageInfo_TLInboxReadUserMediaUnreadToInbox.DiscardUnknown(m)
}

var xxx_messageInfo_TLInboxReadUserMediaUnreadToInbox proto.InternalMessageInfo

func (m *TLInboxReadUserMediaUnreadToInbox) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLInboxReadUserMediaUnreadToInbox) GetFromId() int64 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *TLInboxReadUserMediaUnreadToInbox) GetId() []int32 {
	if m != nil {
		return m.Id
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// inbox.readChatMediaUnreadToInbox from_id:long peer_chat_id:long id:Vector<int> = Void;
type TLInboxReadChatMediaUnreadToInbox struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=inbox.TLConstructor" json:"constructor,omitempty"`
	FromId               int64         `protobuf:"varint,3,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	PeerChatId           int64         `protobuf:"varint,4,opt,name=peer_chat_id,json=peerChatId,proto3" json:"peer_chat_id,omitempty"`
	Id                   []int32       `protobuf:"varint,5,rep,packed,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLInboxReadChatMediaUnreadToInbox) Reset()         { *m = TLInboxReadChatMediaUnreadToInbox{} }
func (m *TLInboxReadChatMediaUnreadToInbox) String() string { return proto.CompactTextString(m) }
func (*TLInboxReadChatMediaUnreadToInbox) ProtoMessage()    {}
func (*TLInboxReadChatMediaUnreadToInbox) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a6f35d665e824e1, []int{12}
}
func (m *TLInboxReadChatMediaUnreadToInbox) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLInboxReadChatMediaUnreadToInbox) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLInboxReadChatMediaUnreadToInbox.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLInboxReadChatMediaUnreadToInbox) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLInboxReadChatMediaUnreadToInbox.Merge(m, src)
}
func (m *TLInboxReadChatMediaUnreadToInbox) XXX_Size() int {
	return m.Size()
}
func (m *TLInboxReadChatMediaUnreadToInbox) XXX_DiscardUnknown() {
	xxx_messageInfo_TLInboxReadChatMediaUnreadToInbox.DiscardUnknown(m)
}

var xxx_messageInfo_TLInboxReadChatMediaUnreadToInbox proto.InternalMessageInfo

func (m *TLInboxReadChatMediaUnreadToInbox) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLInboxReadChatMediaUnreadToInbox) GetFromId() int64 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *TLInboxReadChatMediaUnreadToInbox) GetPeerChatId() int64 {
	if m != nil {
		return m.PeerChatId
	}
	return 0
}

func (m *TLInboxReadChatMediaUnreadToInbox) GetId() []int32 {
	if m != nil {
		return m.Id
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// inbox.updateHistoryReaded from_id:long peer_type:int peer_id:long max_id:int sender:long = Void;
type TLInboxUpdateHistoryReaded struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=inbox.TLConstructor" json:"constructor,omitempty"`
	FromId               int64         `protobuf:"varint,3,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	PeerType             int32         `protobuf:"varint,4,opt,name=peer_type,json=peerType,proto3" json:"peer_type,omitempty"`
	PeerId               int64         `protobuf:"varint,5,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	MaxId                int32         `protobuf:"varint,6,opt,name=max_id,json=maxId,proto3" json:"max_id,omitempty"`
	Sender               int64         `protobuf:"varint,7,opt,name=sender,proto3" json:"sender,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLInboxUpdateHistoryReaded) Reset()         { *m = TLInboxUpdateHistoryReaded{} }
func (m *TLInboxUpdateHistoryReaded) String() string { return proto.CompactTextString(m) }
func (*TLInboxUpdateHistoryReaded) ProtoMessage()    {}
func (*TLInboxUpdateHistoryReaded) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a6f35d665e824e1, []int{13}
}
func (m *TLInboxUpdateHistoryReaded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLInboxUpdateHistoryReaded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLInboxUpdateHistoryReaded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLInboxUpdateHistoryReaded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLInboxUpdateHistoryReaded.Merge(m, src)
}
func (m *TLInboxUpdateHistoryReaded) XXX_Size() int {
	return m.Size()
}
func (m *TLInboxUpdateHistoryReaded) XXX_DiscardUnknown() {
	xxx_messageInfo_TLInboxUpdateHistoryReaded.DiscardUnknown(m)
}

var xxx_messageInfo_TLInboxUpdateHistoryReaded proto.InternalMessageInfo

func (m *TLInboxUpdateHistoryReaded) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLInboxUpdateHistoryReaded) GetFromId() int64 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *TLInboxUpdateHistoryReaded) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *TLInboxUpdateHistoryReaded) GetPeerId() int64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *TLInboxUpdateHistoryReaded) GetMaxId() int32 {
	if m != nil {
		return m.MaxId
	}
	return 0
}

func (m *TLInboxUpdateHistoryReaded) GetSender() int64 {
	if m != nil {
		return m.Sender
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// inbox.updatePinnedMessage flags:# user_id:long unpin:flags.1?true peer_type:int peer_id:long id:int dialog_message_id:long = Void;
type TLInboxUpdatePinnedMessage struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=inbox.TLConstructor" json:"constructor,omitempty"`
	UserId               int64         `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Unpin                bool          `protobuf:"varint,4,opt,name=unpin,proto3" json:"unpin,omitempty"`
	PeerType             int32         `protobuf:"varint,5,opt,name=peer_type,json=peerType,proto3" json:"peer_type,omitempty"`
	PeerId               int64         `protobuf:"varint,6,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	Id                   int32         `protobuf:"varint,7,opt,name=id,proto3" json:"id,omitempty"`
	DialogMessageId      int64         `protobuf:"varint,8,opt,name=dialog_message_id,json=dialogMessageId,proto3" json:"dialog_message_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLInboxUpdatePinnedMessage) Reset()         { *m = TLInboxUpdatePinnedMessage{} }
func (m *TLInboxUpdatePinnedMessage) String() string { return proto.CompactTextString(m) }
func (*TLInboxUpdatePinnedMessage) ProtoMessage()    {}
func (*TLInboxUpdatePinnedMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a6f35d665e824e1, []int{14}
}
func (m *TLInboxUpdatePinnedMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLInboxUpdatePinnedMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLInboxUpdatePinnedMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLInboxUpdatePinnedMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLInboxUpdatePinnedMessage.Merge(m, src)
}
func (m *TLInboxUpdatePinnedMessage) XXX_Size() int {
	return m.Size()
}
func (m *TLInboxUpdatePinnedMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_TLInboxUpdatePinnedMessage.DiscardUnknown(m)
}

var xxx_messageInfo_TLInboxUpdatePinnedMessage proto.InternalMessageInfo

func (m *TLInboxUpdatePinnedMessage) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLInboxUpdatePinnedMessage) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *TLInboxUpdatePinnedMessage) GetUnpin() bool {
	if m != nil {
		return m.Unpin
	}
	return false
}

func (m *TLInboxUpdatePinnedMessage) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *TLInboxUpdatePinnedMessage) GetPeerId() int64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *TLInboxUpdatePinnedMessage) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *TLInboxUpdatePinnedMessage) GetDialogMessageId() int64 {
	if m != nil {
		return m.DialogMessageId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// inbox.unpinAllMessages user_id:long auth_key_id:long peer_type:int peer_id:long = Void;
type TLInboxUnpinAllMessages struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=inbox.TLConstructor" json:"constructor,omitempty"`
	UserId               int64         `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,4,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	PeerType             int32         `protobuf:"varint,5,opt,name=peer_type,json=peerType,proto3" json:"peer_type,omitempty"`
	PeerId               int64         `protobuf:"varint,6,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLInboxUnpinAllMessages) Reset()         { *m = TLInboxUnpinAllMessages{} }
func (m *TLInboxUnpinAllMessages) String() string { return proto.CompactTextString(m) }
func (*TLInboxUnpinAllMessages) ProtoMessage()    {}
func (*TLInboxUnpinAllMessages) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a6f35d665e824e1, []int{15}
}
func (m *TLInboxUnpinAllMessages) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLInboxUnpinAllMessages) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLInboxUnpinAllMessages.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLInboxUnpinAllMessages) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLInboxUnpinAllMessages.Merge(m, src)
}
func (m *TLInboxUnpinAllMessages) XXX_Size() int {
	return m.Size()
}
func (m *TLInboxUnpinAllMessages) XXX_DiscardUnknown() {
	xxx_messageInfo_TLInboxUnpinAllMessages.DiscardUnknown(m)
}

var xxx_messageInfo_TLInboxUnpinAllMessages proto.InternalMessageInfo

func (m *TLInboxUnpinAllMessages) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLInboxUnpinAllMessages) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *TLInboxUnpinAllMessages) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *TLInboxUnpinAllMessages) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *TLInboxUnpinAllMessages) GetPeerId() int64 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func init() {
	proto.RegisterEnum("inbox.TLConstructor", TLConstructor_name, TLConstructor_value)
	proto.RegisterType((*InboxMessageData)(nil), "inbox.InboxMessageData")
	proto.RegisterType((*TLInboxMessageData)(nil), "inbox.TL_inboxMessageData")
	proto.RegisterType((*TLInboxSendUserMessageToInbox)(nil), "inbox.TL_inbox_sendUserMessageToInbox")
	proto.RegisterType((*TLInboxSendChatMessageToInbox)(nil), "inbox.TL_inbox_sendChatMessageToInbox")
	proto.RegisterType((*TLInboxSendUserMultiMessageToInbox)(nil), "inbox.TL_inbox_sendUserMultiMessageToInbox")
	proto.RegisterType((*TLInboxSendChatMultiMessageToInbox)(nil), "inbox.TL_inbox_sendChatMultiMessageToInbox")
	proto.RegisterType((*TLInboxEditUserMessageToInbox)(nil), "inbox.TL_inbox_editUserMessageToInbox")
	proto.RegisterType((*TLInboxEditChatMessageToInbox)(nil), "inbox.TL_inbox_editChatMessageToInbox")
	proto.RegisterType((*TLInboxDeleteMessagesToInbox)(nil), "inbox.TL_inbox_deleteMessagesToInbox")
	proto.RegisterType((*TLInboxDeleteUserHistoryToInbox)(nil), "inbox.TL_inbox_deleteUserHistoryToInbox")
	proto.RegisterType((*TLInboxDeleteChatHistoryToInbox)(nil), "inbox.TL_inbox_deleteChatHistoryToInbox")
	proto.RegisterType((*TLInboxReadUserMediaUnreadToInbox)(nil), "inbox.TL_inbox_readUserMediaUnreadToInbox")
	proto.RegisterType((*TLInboxReadChatMediaUnreadToInbox)(nil), "inbox.TL_inbox_readChatMediaUnreadToInbox")
	proto.RegisterType((*TLInboxUpdateHistoryReaded)(nil), "inbox.TL_inbox_updateHistoryReaded")
	proto.RegisterType((*TLInboxUpdatePinnedMessage)(nil), "inbox.TL_inbox_updatePinnedMessage")
	proto.RegisterType((*TLInboxUnpinAllMessages)(nil), "inbox.TL_inbox_unpinAllMessages")
}

func init() { proto.RegisterFile("inbox.tl.proto", fileDescriptor_9a6f35d665e824e1) }

var fileDescriptor_9a6f35d665e824e1 = []byte{
	// 1248 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x5b, 0x68, 0x1c, 0x55,
	0x18, 0xee, 0x64, 0x33, 0x9b, 0xdd, 0x3f, 0x26, 0x4e, 0xc7, 0x98, 0xe6, 0xe6, 0x76, 0xb3, 0x4d,
	0xeb, 0x9a, 0x36, 0xbb, 0x74, 0x2b, 0xbe, 0xd7, 0xed, 0x83, 0x21, 0x35, 0xd6, 0x31, 0xb1, 0xa0,
	0x0f, 0xcb, 0xc9, 0xce, 0xe9, 0x66, 0x74, 0xe7, 0xc2, 0x99, 0xb3, 0x9a, 0x7d, 0xb4, 0x88, 0xa8,
	0x08, 0xe2, 0x9b, 0x82, 0x88, 0x97, 0x97, 0x12, 0x50, 0x04, 0x15, 0x44, 0x5f, 0xda, 0xa2, 0x58,
	0xb0, 0x0f, 0x3e, 0x54, 0xa9, 0x37, 0x68, 0x23, 0xe8, 0x8b, 0xe2, 0x85, 0xa2, 0xb4, 0x54, 0x94,
	0x33, 0x33, 0xd9, 0xcb, 0x9c, 0x33, 0xd9, 0x6d, 0x6d, 0x63, 0xfa, 0x50, 0xf6, 0x9c, 0xff, 0x3b,
	0xff, 0xff, 0x7d, 0xff, 0x7f, 0x2e, 0xff, 0x04, 0x06, 0x0d, 0x6b, 0xc9, 0x5e, 0xc9, 0xd1, 0x6a,
	0xce, 0x21, 0x36, 0xb5, 0x55, 0xd9, 0x1b, 0x8f, 0xcd, 0x54, 0x0c, 0xba, 0x5c, 0x5b, 0xca, 0x95,
	0x6d, 0x33, 0x5f, 0xb1, 0x2b, 0x76, 0xde, 0xb3, 0x2e, 0xd5, 0x8e, 0x79, 0x23, 0x6f, 0xe0, 0xfd,
	0xf2, 0x57, 0x8d, 0xa5, 0x2a, 0xb6, 0x5d, 0xa9, 0xe2, 0x26, 0xea, 0x49, 0x82, 0x1c, 0x07, 0x13,
	0x37, 0xb0, 0x8f, 0xb9, 0xe5, 0x65, 0x6c, 0x22, 0x16, 0xa6, 0x6c, 0x13, 0x5c, 0xa2, 0x75, 0x07,
	0xaf, 0xdb, 0x46, 0x9b, 0x36, 0x4a, 0x90, 0xe5, 0x3a, 0x36, 0xa1, 0x81, 0x69, 0xa8, 0x69, 0x72,
	0xeb, 0x56, 0xd9, 0x9f, 0xcd, 0xfc, 0x28, 0x81, 0x32, 0xcb, 0x58, 0xde, 0x8f, 0x5d, 0x17, 0x55,
	0xf0, 0x21, 0x44, 0x91, 0xba, 0x1b, 0x06, 0x1d, 0x82, 0x75, 0xa3, 0x8c, 0x28, 0x2e, 0x59, 0xc8,
	0xc4, 0x23, 0x52, 0x5a, 0xca, 0x26, 0xb5, 0x81, 0xc6, 0xec, 0x3c, 0x32, 0xb1, 0x7a, 0x0f, 0xf4,
	0x97, 0x6d, 0xcb, 0xa5, 0xa4, 0x56, 0xa6, 0x36, 0x19, 0xe9, 0x49, 0x4b, 0xd9, 0xc1, 0xc2, 0x50,
	0xce, 0x4f, 0xc2, 0xc2, 0xe1, 0x62, 0xd3, 0xa6, 0xb5, 0x02, 0xd5, 0x71, 0x48, 0x12, 0x64, 0xe9,
	0xb6, 0x59, 0x32, 0xf4, 0x91, 0x58, 0x5a, 0xca, 0xc6, 0xb4, 0x84, 0x3f, 0x31, 0xab, 0xab, 0xd3,
	0xb0, 0x5d, 0x37, 0x50, 0xd5, 0xae, 0x94, 0x4c, 0x9f, 0x11, 0x03, 0xf5, 0x7a, 0xa0, 0x5b, 0x7d,
	0x43, 0xc0, 0xd4, 0xc3, 0xf6, 0x05, 0xa0, 0x11, 0x39, 0x2d, 0x65, 0xfb, 0x0b, 0x4a, 0xce, 0xa4,
	0x9e, 0xae, 0x5c, 0x00, 0xd2, 0xd6, 0x01, 0x99, 0x43, 0x70, 0xdb, 0xc2, 0xe1, 0x92, 0x11, 0x96,
	0x3a, 0x03, 0xb2, 0x8e, 0x28, 0x2a, 0x78, 0x0a, 0xfb, 0x0b, 0x3b, 0x02, 0xf6, 0xe1, 0x94, 0x68,
	0x3e, 0x2a, 0xf3, 0x99, 0x04, 0x3b, 0xd7, 0xdd, 0x94, 0x5c, 0x6c, 0xe9, 0x8b, 0x2e, 0x26, 0x01,
	0x6e, 0xc1, 0xf6, 0x56, 0x85, 0xd3, 0x22, 0x75, 0x9b, 0x96, 0x1d, 0xd0, 0x77, 0x8c, 0xb4, 0x26,
	0x25, 0xce, 0x86, 0xb3, 0xba, 0x9a, 0x86, 0x5b, 0x1c, 0x8c, 0x49, 0xa9, 0xe6, 0x62, 0xd2, 0xcc,
	0x06, 0xb0, 0x39, 0x16, 0x7e, 0x56, 0x57, 0xf7, 0x87, 0x13, 0x11, 0xa9, 0xa3, 0x91, 0x0f, 0x4e,
	0x49, 0x71, 0x19, 0xd1, 0xcd, 0x52, 0x52, 0x5e, 0x46, 0x34, 0xa4, 0x84, 0x85, 0xbf, 0x3e, 0x25,
	0x67, 0x25, 0x98, 0xe2, 0x6b, 0x52, 0xab, 0x52, 0x63, 0x8b, 0x15, 0x26, 0x76, 0x7d, 0x72, 0xbc,
	0xc2, 0x6c, 0xa6, 0x9c, 0x2e, 0xab, 0xd3, 0x9d, 0x9c, 0x93, 0xad, 0xfb, 0x0c, 0xeb, 0x06, 0xdd,
	0x1a, 0x27, 0xe6, 0x5a, 0xae, 0x0e, 0x4e, 0xc2, 0xd6, 0x38, 0x2a, 0xd7, 0x22, 0xe1, 0x29, 0x09,
	0x52, 0x0d, 0x09, 0x3a, 0xae, 0x62, 0x8a, 0x03, 0x8c, 0x7b, 0xd3, 0x14, 0x0c, 0x42, 0x8f, 0xc7,
	0x3b, 0x96, 0x8d, 0x69, 0x3d, 0x86, 0xce, 0x36, 0xf6, 0x64, 0x88, 0x03, 0x2b, 0xc6, 0x7d, 0x86,
	0x4b, 0x6d, 0x52, 0xff, 0x1f, 0xf7, 0xc2, 0x1d, 0x00, 0x8f, 0xd5, 0x5c, 0x5a, 0x2a, 0x57, 0x31,
	0x22, 0x5e, 0x2e, 0x13, 0x5a, 0x92, 0xcd, 0x14, 0xd9, 0x84, 0x7a, 0x3b, 0xc4, 0x4d, 0xb4, 0xc2,
	0x96, 0xc6, 0xd3, 0x52, 0x56, 0xd6, 0x64, 0x13, 0xad, 0xcc, 0xea, 0x99, 0xb7, 0x79, 0x39, 0xac,
	0x30, 0x9b, 0x25, 0x27, 0x7a, 0x5f, 0x34, 0xf9, 0xca, 0xad, 0x7c, 0x9f, 0x91, 0x60, 0x57, 0x83,
	0x2f, 0xc1, 0x28, 0x78, 0xba, 0x74, 0x03, 0x2d, 0x5a, 0x6c, 0xb8, 0x09, 0xfb, 0x40, 0xf6, 0xf6,
	0xc1, 0x89, 0x30, 0x11, 0xff, 0x38, 0xdd, 0x7c, 0x22, 0x9d, 0x53, 0xe7, 0x53, 0x95, 0x1b, 0x54,
	0xcf, 0x49, 0x30, 0xd1, 0xa0, 0x5a, 0x73, 0x74, 0x44, 0x71, 0x50, 0x5f, 0x0d, 0x23, 0x1d, 0xeb,
	0x37, 0x9e, 0xe3, 0x38, 0x24, 0x3d, 0x8e, 0xac, 0xa9, 0xf3, 0x08, 0xca, 0x5a, 0x82, 0x4d, 0x2c,
	0xd4, 0x1d, 0xcc, 0x56, 0x79, 0xc6, 0xa0, 0xb4, 0x31, 0x2d, 0xce, 0x86, 0x6d, 0x25, 0x6f, 0xdd,
	0xa2, 0xea, 0x30, 0xc4, 0xd9, 0x03, 0x82, 0xc9, 0x48, 0x9f, 0x0f, 0xf7, 0x47, 0x99, 0xbf, 0x78,
	0x59, 0x47, 0x0c, 0xcb, 0xc2, 0x7a, 0x70, 0x27, 0xfc, 0x17, 0x59, 0xeb, 0xc7, 0x2c, 0x90, 0x55,
	0xf3, 0x8f, 0xd8, 0x10, 0xc8, 0x35, 0xcb, 0x31, 0x2c, 0x4f, 0x52, 0x42, 0xf3, 0x07, 0xed, 0x62,
	0xe5, 0x68, 0xb1, 0xf1, 0x36, 0xb1, 0x7e, 0x91, 0xfa, 0x3c, 0x78, 0x8f, 0x11, 0xd1, 0x31, 0x26,
	0x84, 0x1d, 0x63, 0xe6, 0xb4, 0x04, 0xa3, 0x4d, 0xe5, 0x8c, 0xc4, 0xc1, 0x6a, 0x75, 0xfd, 0x26,
	0xbc, 0xf1, 0xb2, 0x53, 0xd0, 0x8f, 0x6a, 0x74, 0xb9, 0xf4, 0x38, 0xae, 0x37, 0x37, 0x5c, 0x92,
	0x4d, 0xcd, 0xe1, 0x7a, 0xb8, 0xda, 0xdd, 0x26, 0x60, 0xfa, 0x3b, 0x19, 0x06, 0xda, 0xd8, 0xa8,
	0xdb, 0x61, 0xa0, 0xa8, 0x15, 0x0f, 0x14, 0x4a, 0x8b, 0xf3, 0x73, 0xf3, 0x0f, 0x1c, 0x9d, 0x57,
	0xb6, 0xa9, 0x29, 0x18, 0xf6, 0xa7, 0xc2, 0x2d, 0xaf, 0x72, 0xee, 0xdb, 0x3f, 0xbf, 0x8f, 0xa9,
	0x79, 0xc8, 0xb4, 0xd8, 0x23, 0x7a, 0x59, 0xe5, 0xbd, 0x0f, 0x3e, 0x7e, 0xf5, 0x1f, 0xf6, 0x4f,
	0x12, 0x2d, 0xe0, 0xdf, 0x41, 0xe5, 0xf4, 0x73, 0x5f, 0x7d, 0x78, 0xd9, 0x5f, 0x70, 0x37, 0xdc,
	0x29, 0x8c, 0xc0, 0xb7, 0x32, 0xca, 0xe5, 0xb5, 0x97, 0xde, 0x89, 0x5e, 0x15, 0xd1, 0x00, 0x29,
	0x2f, 0xfc, 0xf0, 0xcb, 0xfb, 0x7f, 0xfb, 0xab, 0xa6, 0xdb, 0xc9, 0x89, 0xfb, 0x0c, 0xe5, 0xc4,
	0xaf, 0x3f, 0xff, 0x24, 0x8b, 0xb0, 0x02, 0x21, 0x2f, 0x5e, 0x3a, 0x75, 0xa6, 0x4f, 0xbd, 0x0b,
	0x26, 0x5b, 0xb1, 0xc2, 0x97, 0x53, 0x79, 0xfa, 0xcd, 0x8f, 0xbe, 0x96, 0xd5, 0x7d, 0x30, 0xc5,
	0x43, 0xf9, 0x07, 0x4e, 0x39, 0x7f, 0x7c, 0xf5, 0x75, 0x49, 0xdd, 0x2f, 0x42, 0xf3, 0xef, 0x87,
	0x72, 0xfc, 0xec, 0xea, 0xa7, 0x81, 0xc6, 0x1c, 0xec, 0x69, 0x5d, 0x12, 0x7d, 0x85, 0x2b, 0xab,
	0xe7, 0xaf, 0x3e, 0xdf, 0x2b, 0xc2, 0x8b, 0x6f, 0x5a, 0xe5, 0xf7, 0x53, 0x27, 0xbf, 0x89, 0xab,
	0xfb, 0x60, 0x67, 0x2b, 0x5e, 0x70, 0xdd, 0x29, 0x17, 0x5e, 0x79, 0xe3, 0xb5, 0xab, 0x3e, 0x1b,
	0x21, 0xba, 0xed, 0x16, 0x51, 0x2e, 0x7d, 0xf9, 0xee, 0xe7, 0x57, 0x7c, 0xf4, 0x14, 0x4c, 0xb4,
	0xa1, 0x43, 0x27, 0x4f, 0xb9, 0xf8, 0xc9, 0x1f, 0x2f, 0xf7, 0x8c, 0xf5, 0x3e, 0xfb, 0x56, 0x6a,
	0x5b, 0xe1, 0x4a, 0x12, 0x12, 0xda, 0x91, 0xa2, 0xff, 0x08, 0x1c, 0x85, 0x89, 0x0d, 0x3f, 0xb6,
	0xf6, 0x34, 0x4e, 0xe7, 0x86, 0x1b, 0x79, 0x6c, 0xa0, 0xd1, 0x1b, 0x3d, 0x6c, 0x1b, 0x7a, 0x66,
	0x5b, 0xbb, 0x63, 0x41, 0x43, 0x27, 0x74, 0xcc, 0xe3, 0x78, 0xc7, 0x08, 0x26, 0x3b, 0x7f, 0x8a,
	0xec, 0x8d, 0xa4, 0xcd, 0x83, 0x3b, 0x84, 0x88, 0xfa, 0x3c, 0xd8, 0x1b, 0x29, 0xa0, 0x9b, 0x10,
	0x8d, 0xf4, 0x44, 0xb4, 0xec, 0x5c, 0x7a, 0xc4, 0xb8, 0x0e, 0x8e, 0xbb, 0xc9, 0xbb, 0x18, 0xc7,
	0x3b, 0x5e, 0x84, 0xf1, 0x8d, 0xda, 0xdb, 0xdd, 0x61, 0xbf, 0x42, 0x18, 0xef, 0xf6, 0x51, 0x48,
	0x75, 0xe8, 0x58, 0xb3, 0x62, 0xcf, 0x3c, 0xb2, 0xa3, 0x73, 0x41, 0xff, 0x18, 0xe1, 0x9c, 0x47,
	0xf2, 0xce, 0x4b, 0x90, 0xee, 0xd8, 0xec, 0x4d, 0x87, 0xdd, 0x47, 0x63, 0x3b, 0x04, 0x88, 0x68,
	0xe2, 0x84, 0x01, 0xc4, 0x58, 0x3e, 0xc0, 0x83, 0x30, 0x1a, 0xdd, 0x7a, 0xed, 0x0a, 0x7b, 0x16,
	0x80, 0x3a, 0xba, 0x6c, 0x6f, 0x7b, 0x22, 0x5c, 0xb6, 0x81, 0x78, 0x97, 0x73, 0x30, 0x1c, 0xd1,
	0x4f, 0xa4, 0x39, 0x7f, 0x21, 0x04, 0xe7, 0xec, 0xde, 0x87, 0x7e, 0xbb, 0x98, 0x92, 0xce, 0xac,
	0xa5, 0xa4, 0x2f, 0xd6, 0x52, 0xd2, 0x85, 0xb5, 0x94, 0xf4, 0xc8, 0xc1, 0x96, 0xbf, 0x1e, 0x52,
	0x8c, 0xcc, 0x0a, 0x41, 0xcd, 0x1f, 0x33, 0x2e, 0x26, 0x4f, 0x60, 0x92, 0x47, 0x8e, 0x93, 0x67,
	0xdd, 0x0f, 0xb6, 0x2a, 0x98, 0xe4, 0x4d, 0xb7, 0x92, 0xf7, 0x02, 0xfa, 0xff, 0x2f, 0xc5, 0xbd,
	0x10, 0x07, 0xfe, 0x0d, 0x00, 0x00, 0xff, 0xff, 0x99, 0x07, 0x59, 0x1c, 0xa0, 0x14, 0x00, 0x00,
}

func (this *InboxMessageData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&inbox.InboxMessageData{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "RandomId: "+fmt.Sprintf("%#v", this.RandomId)+",\n")
	s = append(s, "DialogMessageId: "+fmt.Sprintf("%#v", this.DialogMessageId)+",\n")
	if this.Message != nil {
		s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLInboxMessageData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&inbox.TLInboxMessageData{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLInboxSendUserMessageToInbox) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&inbox.TLInboxSendUserMessageToInbox{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "FromId: "+fmt.Sprintf("%#v", this.FromId)+",\n")
	s = append(s, "PeerUserId: "+fmt.Sprintf("%#v", this.PeerUserId)+",\n")
	if this.Message != nil {
		s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLInboxSendChatMessageToInbox) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&inbox.TLInboxSendChatMessageToInbox{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "FromId: "+fmt.Sprintf("%#v", this.FromId)+",\n")
	s = append(s, "PeerChatId: "+fmt.Sprintf("%#v", this.PeerChatId)+",\n")
	if this.Message != nil {
		s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLInboxSendUserMultiMessageToInbox) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&inbox.TLInboxSendUserMultiMessageToInbox{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "FromId: "+fmt.Sprintf("%#v", this.FromId)+",\n")
	s = append(s, "PeerUserId: "+fmt.Sprintf("%#v", this.PeerUserId)+",\n")
	if this.Message != nil {
		s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLInboxSendChatMultiMessageToInbox) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&inbox.TLInboxSendChatMultiMessageToInbox{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "FromId: "+fmt.Sprintf("%#v", this.FromId)+",\n")
	s = append(s, "PeerChatId: "+fmt.Sprintf("%#v", this.PeerChatId)+",\n")
	if this.Message != nil {
		s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLInboxEditUserMessageToInbox) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&inbox.TLInboxEditUserMessageToInbox{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "FromId: "+fmt.Sprintf("%#v", this.FromId)+",\n")
	s = append(s, "PeerUserId: "+fmt.Sprintf("%#v", this.PeerUserId)+",\n")
	if this.Message != nil {
		s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLInboxEditChatMessageToInbox) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&inbox.TLInboxEditChatMessageToInbox{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "FromId: "+fmt.Sprintf("%#v", this.FromId)+",\n")
	s = append(s, "PeerChatId: "+fmt.Sprintf("%#v", this.PeerChatId)+",\n")
	if this.Message != nil {
		s = append(s, "Message: "+fmt.Sprintf("%#v", this.Message)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLInboxDeleteMessagesToInbox) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&inbox.TLInboxDeleteMessagesToInbox{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "FromId: "+fmt.Sprintf("%#v", this.FromId)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLInboxDeleteUserHistoryToInbox) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&inbox.TLInboxDeleteUserHistoryToInbox{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "FromId: "+fmt.Sprintf("%#v", this.FromId)+",\n")
	s = append(s, "PeerUserId: "+fmt.Sprintf("%#v", this.PeerUserId)+",\n")
	s = append(s, "JustClear: "+fmt.Sprintf("%#v", this.JustClear)+",\n")
	s = append(s, "MaxId: "+fmt.Sprintf("%#v", this.MaxId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLInboxDeleteChatHistoryToInbox) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&inbox.TLInboxDeleteChatHistoryToInbox{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "FromId: "+fmt.Sprintf("%#v", this.FromId)+",\n")
	s = append(s, "PeerChatId: "+fmt.Sprintf("%#v", this.PeerChatId)+",\n")
	s = append(s, "MaxId: "+fmt.Sprintf("%#v", this.MaxId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLInboxReadUserMediaUnreadToInbox) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&inbox.TLInboxReadUserMediaUnreadToInbox{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "FromId: "+fmt.Sprintf("%#v", this.FromId)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLInboxReadChatMediaUnreadToInbox) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&inbox.TLInboxReadChatMediaUnreadToInbox{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "FromId: "+fmt.Sprintf("%#v", this.FromId)+",\n")
	s = append(s, "PeerChatId: "+fmt.Sprintf("%#v", this.PeerChatId)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLInboxUpdateHistoryReaded) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&inbox.TLInboxUpdateHistoryReaded{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "FromId: "+fmt.Sprintf("%#v", this.FromId)+",\n")
	s = append(s, "PeerType: "+fmt.Sprintf("%#v", this.PeerType)+",\n")
	s = append(s, "PeerId: "+fmt.Sprintf("%#v", this.PeerId)+",\n")
	s = append(s, "MaxId: "+fmt.Sprintf("%#v", this.MaxId)+",\n")
	s = append(s, "Sender: "+fmt.Sprintf("%#v", this.Sender)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLInboxUpdatePinnedMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&inbox.TLInboxUpdatePinnedMessage{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "Unpin: "+fmt.Sprintf("%#v", this.Unpin)+",\n")
	s = append(s, "PeerType: "+fmt.Sprintf("%#v", this.PeerType)+",\n")
	s = append(s, "PeerId: "+fmt.Sprintf("%#v", this.PeerId)+",\n")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "DialogMessageId: "+fmt.Sprintf("%#v", this.DialogMessageId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLInboxUnpinAllMessages) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&inbox.TLInboxUnpinAllMessages{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "PeerType: "+fmt.Sprintf("%#v", this.PeerType)+",\n")
	s = append(s, "PeerId: "+fmt.Sprintf("%#v", this.PeerId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringInboxTl(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RPCInboxClient is the client API for RPCInbox service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RPCInboxClient interface {
	// inbox.sendUserMessageToInbox from_id:long peer_user_id:long message:InboxMessageData = Void;
	InboxSendUserMessageToInbox(ctx context.Context, in *TLInboxSendUserMessageToInbox, opts ...grpc.CallOption) (*mtproto.Void, error)
	// inbox.sendChatMessageToInbox from_id:long peer_chat_id:long message:InboxMessageData = Void;
	InboxSendChatMessageToInbox(ctx context.Context, in *TLInboxSendChatMessageToInbox, opts ...grpc.CallOption) (*mtproto.Void, error)
	// inbox.sendUserMultiMessageToInbox from_id:long peer_user_id:long message:Vector<InboxMessageData> = Void;
	InboxSendUserMultiMessageToInbox(ctx context.Context, in *TLInboxSendUserMultiMessageToInbox, opts ...grpc.CallOption) (*mtproto.Void, error)
	// inbox.sendChatMultiMessageToInbox from_id:long peer_chat_id:long message:Vector<InboxMessageData> = Void;
	InboxSendChatMultiMessageToInbox(ctx context.Context, in *TLInboxSendChatMultiMessageToInbox, opts ...grpc.CallOption) (*mtproto.Void, error)
	// inbox.editUserMessageToInbox from_id:long peer_user_id:long message:Message = Void;
	InboxEditUserMessageToInbox(ctx context.Context, in *TLInboxEditUserMessageToInbox, opts ...grpc.CallOption) (*mtproto.Void, error)
	// inbox.editChatMessageToInbox from_id:long peer_chat_id:long message:Message = Void;
	InboxEditChatMessageToInbox(ctx context.Context, in *TLInboxEditChatMessageToInbox, opts ...grpc.CallOption) (*mtproto.Void, error)
	// inbox.deleteMessagesToInbox from_id:long id:Vector<long> = Void;
	InboxDeleteMessagesToInbox(ctx context.Context, in *TLInboxDeleteMessagesToInbox, opts ...grpc.CallOption) (*mtproto.Void, error)
	// inbox.deleteUserHistoryToInbox flags:# from_id:long peer_user_id:long just_clear:flags.1?true max_id:int = Void;
	InboxDeleteUserHistoryToInbox(ctx context.Context, in *TLInboxDeleteUserHistoryToInbox, opts ...grpc.CallOption) (*mtproto.Void, error)
	// inbox.deleteChatHistoryToInbox from_id:long peer_chat_id:long max_id:int = Void;
	InboxDeleteChatHistoryToInbox(ctx context.Context, in *TLInboxDeleteChatHistoryToInbox, opts ...grpc.CallOption) (*mtproto.Void, error)
	// inbox.readUserMediaUnreadToInbox from_id:long id:Vector<int> = Void;
	InboxReadUserMediaUnreadToInbox(ctx context.Context, in *TLInboxReadUserMediaUnreadToInbox, opts ...grpc.CallOption) (*mtproto.Void, error)
	// inbox.readChatMediaUnreadToInbox from_id:long peer_chat_id:long id:Vector<int> = Void;
	InboxReadChatMediaUnreadToInbox(ctx context.Context, in *TLInboxReadChatMediaUnreadToInbox, opts ...grpc.CallOption) (*mtproto.Void, error)
	// inbox.updateHistoryReaded from_id:long peer_type:int peer_id:long max_id:int sender:long = Void;
	InboxUpdateHistoryReaded(ctx context.Context, in *TLInboxUpdateHistoryReaded, opts ...grpc.CallOption) (*mtproto.Void, error)
	// inbox.updatePinnedMessage flags:# user_id:long unpin:flags.1?true peer_type:int peer_id:long id:int dialog_message_id:long = Void;
	InboxUpdatePinnedMessage(ctx context.Context, in *TLInboxUpdatePinnedMessage, opts ...grpc.CallOption) (*mtproto.Void, error)
	// inbox.unpinAllMessages user_id:long auth_key_id:long peer_type:int peer_id:long = Void;
	InboxUnpinAllMessages(ctx context.Context, in *TLInboxUnpinAllMessages, opts ...grpc.CallOption) (*mtproto.Void, error)
}

type rPCInboxClient struct {
	cc *grpc.ClientConn
}

func NewRPCInboxClient(cc *grpc.ClientConn) RPCInboxClient {
	return &rPCInboxClient{cc}
}

func (c *rPCInboxClient) InboxSendUserMessageToInbox(ctx context.Context, in *TLInboxSendUserMessageToInbox, opts ...grpc.CallOption) (*mtproto.Void, error) {
	out := new(mtproto.Void)
	err := c.cc.Invoke(ctx, "/inbox.RPCInbox/inbox_sendUserMessageToInbox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCInboxClient) InboxSendChatMessageToInbox(ctx context.Context, in *TLInboxSendChatMessageToInbox, opts ...grpc.CallOption) (*mtproto.Void, error) {
	out := new(mtproto.Void)
	err := c.cc.Invoke(ctx, "/inbox.RPCInbox/inbox_sendChatMessageToInbox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCInboxClient) InboxSendUserMultiMessageToInbox(ctx context.Context, in *TLInboxSendUserMultiMessageToInbox, opts ...grpc.CallOption) (*mtproto.Void, error) {
	out := new(mtproto.Void)
	err := c.cc.Invoke(ctx, "/inbox.RPCInbox/inbox_sendUserMultiMessageToInbox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCInboxClient) InboxSendChatMultiMessageToInbox(ctx context.Context, in *TLInboxSendChatMultiMessageToInbox, opts ...grpc.CallOption) (*mtproto.Void, error) {
	out := new(mtproto.Void)
	err := c.cc.Invoke(ctx, "/inbox.RPCInbox/inbox_sendChatMultiMessageToInbox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCInboxClient) InboxEditUserMessageToInbox(ctx context.Context, in *TLInboxEditUserMessageToInbox, opts ...grpc.CallOption) (*mtproto.Void, error) {
	out := new(mtproto.Void)
	err := c.cc.Invoke(ctx, "/inbox.RPCInbox/inbox_editUserMessageToInbox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCInboxClient) InboxEditChatMessageToInbox(ctx context.Context, in *TLInboxEditChatMessageToInbox, opts ...grpc.CallOption) (*mtproto.Void, error) {
	out := new(mtproto.Void)
	err := c.cc.Invoke(ctx, "/inbox.RPCInbox/inbox_editChatMessageToInbox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCInboxClient) InboxDeleteMessagesToInbox(ctx context.Context, in *TLInboxDeleteMessagesToInbox, opts ...grpc.CallOption) (*mtproto.Void, error) {
	out := new(mtproto.Void)
	err := c.cc.Invoke(ctx, "/inbox.RPCInbox/inbox_deleteMessagesToInbox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCInboxClient) InboxDeleteUserHistoryToInbox(ctx context.Context, in *TLInboxDeleteUserHistoryToInbox, opts ...grpc.CallOption) (*mtproto.Void, error) {
	out := new(mtproto.Void)
	err := c.cc.Invoke(ctx, "/inbox.RPCInbox/inbox_deleteUserHistoryToInbox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCInboxClient) InboxDeleteChatHistoryToInbox(ctx context.Context, in *TLInboxDeleteChatHistoryToInbox, opts ...grpc.CallOption) (*mtproto.Void, error) {
	out := new(mtproto.Void)
	err := c.cc.Invoke(ctx, "/inbox.RPCInbox/inbox_deleteChatHistoryToInbox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCInboxClient) InboxReadUserMediaUnreadToInbox(ctx context.Context, in *TLInboxReadUserMediaUnreadToInbox, opts ...grpc.CallOption) (*mtproto.Void, error) {
	out := new(mtproto.Void)
	err := c.cc.Invoke(ctx, "/inbox.RPCInbox/inbox_readUserMediaUnreadToInbox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCInboxClient) InboxReadChatMediaUnreadToInbox(ctx context.Context, in *TLInboxReadChatMediaUnreadToInbox, opts ...grpc.CallOption) (*mtproto.Void, error) {
	out := new(mtproto.Void)
	err := c.cc.Invoke(ctx, "/inbox.RPCInbox/inbox_readChatMediaUnreadToInbox", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCInboxClient) InboxUpdateHistoryReaded(ctx context.Context, in *TLInboxUpdateHistoryReaded, opts ...grpc.CallOption) (*mtproto.Void, error) {
	out := new(mtproto.Void)
	err := c.cc.Invoke(ctx, "/inbox.RPCInbox/inbox_updateHistoryReaded", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCInboxClient) InboxUpdatePinnedMessage(ctx context.Context, in *TLInboxUpdatePinnedMessage, opts ...grpc.CallOption) (*mtproto.Void, error) {
	out := new(mtproto.Void)
	err := c.cc.Invoke(ctx, "/inbox.RPCInbox/inbox_updatePinnedMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCInboxClient) InboxUnpinAllMessages(ctx context.Context, in *TLInboxUnpinAllMessages, opts ...grpc.CallOption) (*mtproto.Void, error) {
	out := new(mtproto.Void)
	err := c.cc.Invoke(ctx, "/inbox.RPCInbox/inbox_unpinAllMessages", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RPCInboxServer is the server API for RPCInbox service.
type RPCInboxServer interface {
	// inbox.sendUserMessageToInbox from_id:long peer_user_id:long message:InboxMessageData = Void;
	InboxSendUserMessageToInbox(context.Context, *TLInboxSendUserMessageToInbox) (*mtproto.Void, error)
	// inbox.sendChatMessageToInbox from_id:long peer_chat_id:long message:InboxMessageData = Void;
	InboxSendChatMessageToInbox(context.Context, *TLInboxSendChatMessageToInbox) (*mtproto.Void, error)
	// inbox.sendUserMultiMessageToInbox from_id:long peer_user_id:long message:Vector<InboxMessageData> = Void;
	InboxSendUserMultiMessageToInbox(context.Context, *TLInboxSendUserMultiMessageToInbox) (*mtproto.Void, error)
	// inbox.sendChatMultiMessageToInbox from_id:long peer_chat_id:long message:Vector<InboxMessageData> = Void;
	InboxSendChatMultiMessageToInbox(context.Context, *TLInboxSendChatMultiMessageToInbox) (*mtproto.Void, error)
	// inbox.editUserMessageToInbox from_id:long peer_user_id:long message:Message = Void;
	InboxEditUserMessageToInbox(context.Context, *TLInboxEditUserMessageToInbox) (*mtproto.Void, error)
	// inbox.editChatMessageToInbox from_id:long peer_chat_id:long message:Message = Void;
	InboxEditChatMessageToInbox(context.Context, *TLInboxEditChatMessageToInbox) (*mtproto.Void, error)
	// inbox.deleteMessagesToInbox from_id:long id:Vector<long> = Void;
	InboxDeleteMessagesToInbox(context.Context, *TLInboxDeleteMessagesToInbox) (*mtproto.Void, error)
	// inbox.deleteUserHistoryToInbox flags:# from_id:long peer_user_id:long just_clear:flags.1?true max_id:int = Void;
	InboxDeleteUserHistoryToInbox(context.Context, *TLInboxDeleteUserHistoryToInbox) (*mtproto.Void, error)
	// inbox.deleteChatHistoryToInbox from_id:long peer_chat_id:long max_id:int = Void;
	InboxDeleteChatHistoryToInbox(context.Context, *TLInboxDeleteChatHistoryToInbox) (*mtproto.Void, error)
	// inbox.readUserMediaUnreadToInbox from_id:long id:Vector<int> = Void;
	InboxReadUserMediaUnreadToInbox(context.Context, *TLInboxReadUserMediaUnreadToInbox) (*mtproto.Void, error)
	// inbox.readChatMediaUnreadToInbox from_id:long peer_chat_id:long id:Vector<int> = Void;
	InboxReadChatMediaUnreadToInbox(context.Context, *TLInboxReadChatMediaUnreadToInbox) (*mtproto.Void, error)
	// inbox.updateHistoryReaded from_id:long peer_type:int peer_id:long max_id:int sender:long = Void;
	InboxUpdateHistoryReaded(context.Context, *TLInboxUpdateHistoryReaded) (*mtproto.Void, error)
	// inbox.updatePinnedMessage flags:# user_id:long unpin:flags.1?true peer_type:int peer_id:long id:int dialog_message_id:long = Void;
	InboxUpdatePinnedMessage(context.Context, *TLInboxUpdatePinnedMessage) (*mtproto.Void, error)
	// inbox.unpinAllMessages user_id:long auth_key_id:long peer_type:int peer_id:long = Void;
	InboxUnpinAllMessages(context.Context, *TLInboxUnpinAllMessages) (*mtproto.Void, error)
}

// UnimplementedRPCInboxServer can be embedded to have forward compatible implementations.
type UnimplementedRPCInboxServer struct {
}

func (*UnimplementedRPCInboxServer) InboxSendUserMessageToInbox(ctx context.Context, req *TLInboxSendUserMessageToInbox) (*mtproto.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InboxSendUserMessageToInbox not implemented")
}
func (*UnimplementedRPCInboxServer) InboxSendChatMessageToInbox(ctx context.Context, req *TLInboxSendChatMessageToInbox) (*mtproto.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InboxSendChatMessageToInbox not implemented")
}
func (*UnimplementedRPCInboxServer) InboxSendUserMultiMessageToInbox(ctx context.Context, req *TLInboxSendUserMultiMessageToInbox) (*mtproto.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InboxSendUserMultiMessageToInbox not implemented")
}
func (*UnimplementedRPCInboxServer) InboxSendChatMultiMessageToInbox(ctx context.Context, req *TLInboxSendChatMultiMessageToInbox) (*mtproto.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InboxSendChatMultiMessageToInbox not implemented")
}
func (*UnimplementedRPCInboxServer) InboxEditUserMessageToInbox(ctx context.Context, req *TLInboxEditUserMessageToInbox) (*mtproto.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InboxEditUserMessageToInbox not implemented")
}
func (*UnimplementedRPCInboxServer) InboxEditChatMessageToInbox(ctx context.Context, req *TLInboxEditChatMessageToInbox) (*mtproto.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InboxEditChatMessageToInbox not implemented")
}
func (*UnimplementedRPCInboxServer) InboxDeleteMessagesToInbox(ctx context.Context, req *TLInboxDeleteMessagesToInbox) (*mtproto.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InboxDeleteMessagesToInbox not implemented")
}
func (*UnimplementedRPCInboxServer) InboxDeleteUserHistoryToInbox(ctx context.Context, req *TLInboxDeleteUserHistoryToInbox) (*mtproto.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InboxDeleteUserHistoryToInbox not implemented")
}
func (*UnimplementedRPCInboxServer) InboxDeleteChatHistoryToInbox(ctx context.Context, req *TLInboxDeleteChatHistoryToInbox) (*mtproto.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InboxDeleteChatHistoryToInbox not implemented")
}
func (*UnimplementedRPCInboxServer) InboxReadUserMediaUnreadToInbox(ctx context.Context, req *TLInboxReadUserMediaUnreadToInbox) (*mtproto.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InboxReadUserMediaUnreadToInbox not implemented")
}
func (*UnimplementedRPCInboxServer) InboxReadChatMediaUnreadToInbox(ctx context.Context, req *TLInboxReadChatMediaUnreadToInbox) (*mtproto.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InboxReadChatMediaUnreadToInbox not implemented")
}
func (*UnimplementedRPCInboxServer) InboxUpdateHistoryReaded(ctx context.Context, req *TLInboxUpdateHistoryReaded) (*mtproto.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InboxUpdateHistoryReaded not implemented")
}
func (*UnimplementedRPCInboxServer) InboxUpdatePinnedMessage(ctx context.Context, req *TLInboxUpdatePinnedMessage) (*mtproto.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InboxUpdatePinnedMessage not implemented")
}
func (*UnimplementedRPCInboxServer) InboxUnpinAllMessages(ctx context.Context, req *TLInboxUnpinAllMessages) (*mtproto.Void, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InboxUnpinAllMessages not implemented")
}

func RegisterRPCInboxServer(s *grpc.Server, srv RPCInboxServer) {
	s.RegisterService(&_RPCInbox_serviceDesc, srv)
}

func _RPCInbox_InboxSendUserMessageToInbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLInboxSendUserMessageToInbox)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCInboxServer).InboxSendUserMessageToInbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inbox.RPCInbox/InboxSendUserMessageToInbox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCInboxServer).InboxSendUserMessageToInbox(ctx, req.(*TLInboxSendUserMessageToInbox))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCInbox_InboxSendChatMessageToInbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLInboxSendChatMessageToInbox)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCInboxServer).InboxSendChatMessageToInbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inbox.RPCInbox/InboxSendChatMessageToInbox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCInboxServer).InboxSendChatMessageToInbox(ctx, req.(*TLInboxSendChatMessageToInbox))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCInbox_InboxSendUserMultiMessageToInbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLInboxSendUserMultiMessageToInbox)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCInboxServer).InboxSendUserMultiMessageToInbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inbox.RPCInbox/InboxSendUserMultiMessageToInbox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCInboxServer).InboxSendUserMultiMessageToInbox(ctx, req.(*TLInboxSendUserMultiMessageToInbox))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCInbox_InboxSendChatMultiMessageToInbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLInboxSendChatMultiMessageToInbox)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCInboxServer).InboxSendChatMultiMessageToInbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inbox.RPCInbox/InboxSendChatMultiMessageToInbox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCInboxServer).InboxSendChatMultiMessageToInbox(ctx, req.(*TLInboxSendChatMultiMessageToInbox))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCInbox_InboxEditUserMessageToInbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLInboxEditUserMessageToInbox)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCInboxServer).InboxEditUserMessageToInbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inbox.RPCInbox/InboxEditUserMessageToInbox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCInboxServer).InboxEditUserMessageToInbox(ctx, req.(*TLInboxEditUserMessageToInbox))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCInbox_InboxEditChatMessageToInbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLInboxEditChatMessageToInbox)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCInboxServer).InboxEditChatMessageToInbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inbox.RPCInbox/InboxEditChatMessageToInbox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCInboxServer).InboxEditChatMessageToInbox(ctx, req.(*TLInboxEditChatMessageToInbox))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCInbox_InboxDeleteMessagesToInbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLInboxDeleteMessagesToInbox)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCInboxServer).InboxDeleteMessagesToInbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inbox.RPCInbox/InboxDeleteMessagesToInbox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCInboxServer).InboxDeleteMessagesToInbox(ctx, req.(*TLInboxDeleteMessagesToInbox))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCInbox_InboxDeleteUserHistoryToInbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLInboxDeleteUserHistoryToInbox)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCInboxServer).InboxDeleteUserHistoryToInbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inbox.RPCInbox/InboxDeleteUserHistoryToInbox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCInboxServer).InboxDeleteUserHistoryToInbox(ctx, req.(*TLInboxDeleteUserHistoryToInbox))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCInbox_InboxDeleteChatHistoryToInbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLInboxDeleteChatHistoryToInbox)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCInboxServer).InboxDeleteChatHistoryToInbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inbox.RPCInbox/InboxDeleteChatHistoryToInbox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCInboxServer).InboxDeleteChatHistoryToInbox(ctx, req.(*TLInboxDeleteChatHistoryToInbox))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCInbox_InboxReadUserMediaUnreadToInbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLInboxReadUserMediaUnreadToInbox)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCInboxServer).InboxReadUserMediaUnreadToInbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inbox.RPCInbox/InboxReadUserMediaUnreadToInbox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCInboxServer).InboxReadUserMediaUnreadToInbox(ctx, req.(*TLInboxReadUserMediaUnreadToInbox))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCInbox_InboxReadChatMediaUnreadToInbox_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLInboxReadChatMediaUnreadToInbox)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCInboxServer).InboxReadChatMediaUnreadToInbox(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inbox.RPCInbox/InboxReadChatMediaUnreadToInbox",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCInboxServer).InboxReadChatMediaUnreadToInbox(ctx, req.(*TLInboxReadChatMediaUnreadToInbox))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCInbox_InboxUpdateHistoryReaded_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLInboxUpdateHistoryReaded)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCInboxServer).InboxUpdateHistoryReaded(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inbox.RPCInbox/InboxUpdateHistoryReaded",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCInboxServer).InboxUpdateHistoryReaded(ctx, req.(*TLInboxUpdateHistoryReaded))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCInbox_InboxUpdatePinnedMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLInboxUpdatePinnedMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCInboxServer).InboxUpdatePinnedMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inbox.RPCInbox/InboxUpdatePinnedMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCInboxServer).InboxUpdatePinnedMessage(ctx, req.(*TLInboxUpdatePinnedMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCInbox_InboxUnpinAllMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLInboxUnpinAllMessages)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCInboxServer).InboxUnpinAllMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/inbox.RPCInbox/InboxUnpinAllMessages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCInboxServer).InboxUnpinAllMessages(ctx, req.(*TLInboxUnpinAllMessages))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPCInbox_serviceDesc = grpc.ServiceDesc{
	ServiceName: "inbox.RPCInbox",
	HandlerType: (*RPCInboxServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "inbox_sendUserMessageToInbox",
			Handler:    _RPCInbox_InboxSendUserMessageToInbox_Handler,
		},
		{
			MethodName: "inbox_sendChatMessageToInbox",
			Handler:    _RPCInbox_InboxSendChatMessageToInbox_Handler,
		},
		{
			MethodName: "inbox_sendUserMultiMessageToInbox",
			Handler:    _RPCInbox_InboxSendUserMultiMessageToInbox_Handler,
		},
		{
			MethodName: "inbox_sendChatMultiMessageToInbox",
			Handler:    _RPCInbox_InboxSendChatMultiMessageToInbox_Handler,
		},
		{
			MethodName: "inbox_editUserMessageToInbox",
			Handler:    _RPCInbox_InboxEditUserMessageToInbox_Handler,
		},
		{
			MethodName: "inbox_editChatMessageToInbox",
			Handler:    _RPCInbox_InboxEditChatMessageToInbox_Handler,
		},
		{
			MethodName: "inbox_deleteMessagesToInbox",
			Handler:    _RPCInbox_InboxDeleteMessagesToInbox_Handler,
		},
		{
			MethodName: "inbox_deleteUserHistoryToInbox",
			Handler:    _RPCInbox_InboxDeleteUserHistoryToInbox_Handler,
		},
		{
			MethodName: "inbox_deleteChatHistoryToInbox",
			Handler:    _RPCInbox_InboxDeleteChatHistoryToInbox_Handler,
		},
		{
			MethodName: "inbox_readUserMediaUnreadToInbox",
			Handler:    _RPCInbox_InboxReadUserMediaUnreadToInbox_Handler,
		},
		{
			MethodName: "inbox_readChatMediaUnreadToInbox",
			Handler:    _RPCInbox_InboxReadChatMediaUnreadToInbox_Handler,
		},
		{
			MethodName: "inbox_updateHistoryReaded",
			Handler:    _RPCInbox_InboxUpdateHistoryReaded_Handler,
		},
		{
			MethodName: "inbox_updatePinnedMessage",
			Handler:    _RPCInbox_InboxUpdatePinnedMessage_Handler,
		},
		{
			MethodName: "inbox_unpinAllMessages",
			Handler:    _RPCInbox_InboxUnpinAllMessages_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "inbox.tl.proto",
}

func (m *InboxMessageData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InboxMessageData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InboxMessageData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInboxTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DialogMessageId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.DialogMessageId))
		i--
		dAtA[i] = 0x20
	}
	if m.RandomId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.RandomId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintInboxTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLInboxMessageData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLInboxMessageData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLInboxMessageData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInboxTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLInboxSendUserMessageToInbox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLInboxSendUserMessageToInbox) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLInboxSendUserMessageToInbox) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInboxTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.PeerUserId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.PeerUserId))
		i--
		dAtA[i] = 0x20
	}
	if m.FromId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.FromId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLInboxSendChatMessageToInbox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLInboxSendChatMessageToInbox) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLInboxSendChatMessageToInbox) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInboxTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.PeerChatId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.PeerChatId))
		i--
		dAtA[i] = 0x20
	}
	if m.FromId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.FromId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLInboxSendUserMultiMessageToInbox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLInboxSendUserMultiMessageToInbox) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLInboxSendUserMultiMessageToInbox) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		for iNdEx := len(m.Message) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Message[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInboxTl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.PeerUserId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.PeerUserId))
		i--
		dAtA[i] = 0x20
	}
	if m.FromId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.FromId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLInboxSendChatMultiMessageToInbox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLInboxSendChatMultiMessageToInbox) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLInboxSendChatMultiMessageToInbox) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		for iNdEx := len(m.Message) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Message[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintInboxTl(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.PeerChatId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.PeerChatId))
		i--
		dAtA[i] = 0x20
	}
	if m.FromId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.FromId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLInboxEditUserMessageToInbox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLInboxEditUserMessageToInbox) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLInboxEditUserMessageToInbox) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInboxTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.PeerUserId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.PeerUserId))
		i--
		dAtA[i] = 0x20
	}
	if m.FromId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.FromId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLInboxEditChatMessageToInbox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLInboxEditChatMessageToInbox) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLInboxEditChatMessageToInbox) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Message != nil {
		{
			size, err := m.Message.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintInboxTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.PeerChatId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.PeerChatId))
		i--
		dAtA[i] = 0x20
	}
	if m.FromId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.FromId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLInboxDeleteMessagesToInbox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLInboxDeleteMessagesToInbox) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLInboxDeleteMessagesToInbox) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		dAtA8 := make([]byte, len(m.Id)*10)
		var j7 int
		for _, num1 := range m.Id {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintInboxTl(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x22
	}
	if m.FromId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.FromId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLInboxDeleteUserHistoryToInbox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLInboxDeleteUserHistoryToInbox) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLInboxDeleteUserHistoryToInbox) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.MaxId))
		i--
		dAtA[i] = 0x30
	}
	if m.JustClear {
		i--
		if m.JustClear {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.PeerUserId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.PeerUserId))
		i--
		dAtA[i] = 0x20
	}
	if m.FromId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.FromId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLInboxDeleteChatHistoryToInbox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLInboxDeleteChatHistoryToInbox) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLInboxDeleteChatHistoryToInbox) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.MaxId))
		i--
		dAtA[i] = 0x28
	}
	if m.PeerChatId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.PeerChatId))
		i--
		dAtA[i] = 0x20
	}
	if m.FromId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.FromId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLInboxReadUserMediaUnreadToInbox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLInboxReadUserMediaUnreadToInbox) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLInboxReadUserMediaUnreadToInbox) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		dAtA10 := make([]byte, len(m.Id)*10)
		var j9 int
		for _, num1 := range m.Id {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintInboxTl(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x22
	}
	if m.FromId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.FromId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLInboxReadChatMediaUnreadToInbox) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLInboxReadChatMediaUnreadToInbox) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLInboxReadChatMediaUnreadToInbox) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		dAtA12 := make([]byte, len(m.Id)*10)
		var j11 int
		for _, num1 := range m.Id {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintInboxTl(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x2a
	}
	if m.PeerChatId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.PeerChatId))
		i--
		dAtA[i] = 0x20
	}
	if m.FromId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.FromId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLInboxUpdateHistoryReaded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLInboxUpdateHistoryReaded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLInboxUpdateHistoryReaded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Sender != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.Sender))
		i--
		dAtA[i] = 0x38
	}
	if m.MaxId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.MaxId))
		i--
		dAtA[i] = 0x30
	}
	if m.PeerId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x28
	}
	if m.PeerType != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.PeerType))
		i--
		dAtA[i] = 0x20
	}
	if m.FromId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.FromId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLInboxUpdatePinnedMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLInboxUpdatePinnedMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLInboxUpdatePinnedMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DialogMessageId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.DialogMessageId))
		i--
		dAtA[i] = 0x40
	}
	if m.Id != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x38
	}
	if m.PeerId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x30
	}
	if m.PeerType != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.PeerType))
		i--
		dAtA[i] = 0x28
	}
	if m.Unpin {
		i--
		if m.Unpin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.UserId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLInboxUnpinAllMessages) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLInboxUnpinAllMessages) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLInboxUnpinAllMessages) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PeerId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x30
	}
	if m.PeerType != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.PeerType))
		i--
		dAtA[i] = 0x28
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x20
	}
	if m.UserId != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintInboxTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintInboxTl(dAtA []byte, offset int, v uint64) int {
	offset -= sovInboxTl(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *InboxMessageData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovInboxTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovInboxTl(uint64(m.Constructor))
	}
	if m.RandomId != 0 {
		n += 1 + sovInboxTl(uint64(m.RandomId))
	}
	if m.DialogMessageId != 0 {
		n += 1 + sovInboxTl(uint64(m.DialogMessageId))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovInboxTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLInboxMessageData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovInboxTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLInboxSendUserMessageToInbox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovInboxTl(uint64(m.Constructor))
	}
	if m.FromId != 0 {
		n += 1 + sovInboxTl(uint64(m.FromId))
	}
	if m.PeerUserId != 0 {
		n += 1 + sovInboxTl(uint64(m.PeerUserId))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovInboxTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLInboxSendChatMessageToInbox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovInboxTl(uint64(m.Constructor))
	}
	if m.FromId != 0 {
		n += 1 + sovInboxTl(uint64(m.FromId))
	}
	if m.PeerChatId != 0 {
		n += 1 + sovInboxTl(uint64(m.PeerChatId))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovInboxTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLInboxSendUserMultiMessageToInbox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovInboxTl(uint64(m.Constructor))
	}
	if m.FromId != 0 {
		n += 1 + sovInboxTl(uint64(m.FromId))
	}
	if m.PeerUserId != 0 {
		n += 1 + sovInboxTl(uint64(m.PeerUserId))
	}
	if len(m.Message) > 0 {
		for _, e := range m.Message {
			l = e.Size()
			n += 1 + l + sovInboxTl(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLInboxSendChatMultiMessageToInbox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovInboxTl(uint64(m.Constructor))
	}
	if m.FromId != 0 {
		n += 1 + sovInboxTl(uint64(m.FromId))
	}
	if m.PeerChatId != 0 {
		n += 1 + sovInboxTl(uint64(m.PeerChatId))
	}
	if len(m.Message) > 0 {
		for _, e := range m.Message {
			l = e.Size()
			n += 1 + l + sovInboxTl(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLInboxEditUserMessageToInbox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovInboxTl(uint64(m.Constructor))
	}
	if m.FromId != 0 {
		n += 1 + sovInboxTl(uint64(m.FromId))
	}
	if m.PeerUserId != 0 {
		n += 1 + sovInboxTl(uint64(m.PeerUserId))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovInboxTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLInboxEditChatMessageToInbox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovInboxTl(uint64(m.Constructor))
	}
	if m.FromId != 0 {
		n += 1 + sovInboxTl(uint64(m.FromId))
	}
	if m.PeerChatId != 0 {
		n += 1 + sovInboxTl(uint64(m.PeerChatId))
	}
	if m.Message != nil {
		l = m.Message.Size()
		n += 1 + l + sovInboxTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLInboxDeleteMessagesToInbox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovInboxTl(uint64(m.Constructor))
	}
	if m.FromId != 0 {
		n += 1 + sovInboxTl(uint64(m.FromId))
	}
	if len(m.Id) > 0 {
		l = 0
		for _, e := range m.Id {
			l += sovInboxTl(uint64(e))
		}
		n += 1 + sovInboxTl(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLInboxDeleteUserHistoryToInbox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovInboxTl(uint64(m.Constructor))
	}
	if m.FromId != 0 {
		n += 1 + sovInboxTl(uint64(m.FromId))
	}
	if m.PeerUserId != 0 {
		n += 1 + sovInboxTl(uint64(m.PeerUserId))
	}
	if m.JustClear {
		n += 2
	}
	if m.MaxId != 0 {
		n += 1 + sovInboxTl(uint64(m.MaxId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLInboxDeleteChatHistoryToInbox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovInboxTl(uint64(m.Constructor))
	}
	if m.FromId != 0 {
		n += 1 + sovInboxTl(uint64(m.FromId))
	}
	if m.PeerChatId != 0 {
		n += 1 + sovInboxTl(uint64(m.PeerChatId))
	}
	if m.MaxId != 0 {
		n += 1 + sovInboxTl(uint64(m.MaxId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLInboxReadUserMediaUnreadToInbox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovInboxTl(uint64(m.Constructor))
	}
	if m.FromId != 0 {
		n += 1 + sovInboxTl(uint64(m.FromId))
	}
	if len(m.Id) > 0 {
		l = 0
		for _, e := range m.Id {
			l += sovInboxTl(uint64(e))
		}
		n += 1 + sovInboxTl(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLInboxReadChatMediaUnreadToInbox) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovInboxTl(uint64(m.Constructor))
	}
	if m.FromId != 0 {
		n += 1 + sovInboxTl(uint64(m.FromId))
	}
	if m.PeerChatId != 0 {
		n += 1 + sovInboxTl(uint64(m.PeerChatId))
	}
	if len(m.Id) > 0 {
		l = 0
		for _, e := range m.Id {
			l += sovInboxTl(uint64(e))
		}
		n += 1 + sovInboxTl(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLInboxUpdateHistoryReaded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovInboxTl(uint64(m.Constructor))
	}
	if m.FromId != 0 {
		n += 1 + sovInboxTl(uint64(m.FromId))
	}
	if m.PeerType != 0 {
		n += 1 + sovInboxTl(uint64(m.PeerType))
	}
	if m.PeerId != 0 {
		n += 1 + sovInboxTl(uint64(m.PeerId))
	}
	if m.MaxId != 0 {
		n += 1 + sovInboxTl(uint64(m.MaxId))
	}
	if m.Sender != 0 {
		n += 1 + sovInboxTl(uint64(m.Sender))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLInboxUpdatePinnedMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovInboxTl(uint64(m.Constructor))
	}
	if m.UserId != 0 {
		n += 1 + sovInboxTl(uint64(m.UserId))
	}
	if m.Unpin {
		n += 2
	}
	if m.PeerType != 0 {
		n += 1 + sovInboxTl(uint64(m.PeerType))
	}
	if m.PeerId != 0 {
		n += 1 + sovInboxTl(uint64(m.PeerId))
	}
	if m.Id != 0 {
		n += 1 + sovInboxTl(uint64(m.Id))
	}
	if m.DialogMessageId != 0 {
		n += 1 + sovInboxTl(uint64(m.DialogMessageId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLInboxUnpinAllMessages) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovInboxTl(uint64(m.Constructor))
	}
	if m.UserId != 0 {
		n += 1 + sovInboxTl(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovInboxTl(uint64(m.AuthKeyId))
	}
	if m.PeerType != 0 {
		n += 1 + sovInboxTl(uint64(m.PeerType))
	}
	if m.PeerId != 0 {
		n += 1 + sovInboxTl(uint64(m.PeerId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovInboxTl(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozInboxTl(x uint64) (n int) {
	return sovInboxTl(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *InboxMessageData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInboxTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InboxMessageData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InboxMessageData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInboxTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInboxTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomId", wireType)
			}
			m.RandomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DialogMessageId", wireType)
			}
			m.DialogMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DialogMessageId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInboxTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInboxTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &mtproto.Message{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInboxTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInboxTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLInboxMessageData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInboxTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_inboxMessageData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_inboxMessageData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInboxTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInboxTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &InboxMessageData{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInboxTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInboxTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLInboxSendUserMessageToInbox) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInboxTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_inbox_sendUserMessageToInbox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_inbox_sendUserMessageToInbox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerUserId", wireType)
			}
			m.PeerUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerUserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInboxTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInboxTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &InboxMessageData{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInboxTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInboxTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLInboxSendChatMessageToInbox) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInboxTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_inbox_sendChatMessageToInbox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_inbox_sendChatMessageToInbox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerChatId", wireType)
			}
			m.PeerChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInboxTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInboxTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &InboxMessageData{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInboxTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInboxTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLInboxSendUserMultiMessageToInbox) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInboxTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_inbox_sendUserMultiMessageToInbox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_inbox_sendUserMultiMessageToInbox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerUserId", wireType)
			}
			m.PeerUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerUserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInboxTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInboxTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message, &InboxMessageData{})
			if err := m.Message[len(m.Message)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInboxTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInboxTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLInboxSendChatMultiMessageToInbox) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInboxTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_inbox_sendChatMultiMessageToInbox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_inbox_sendChatMultiMessageToInbox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerChatId", wireType)
			}
			m.PeerChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInboxTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInboxTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message, &InboxMessageData{})
			if err := m.Message[len(m.Message)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInboxTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInboxTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLInboxEditUserMessageToInbox) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInboxTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_inbox_editUserMessageToInbox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_inbox_editUserMessageToInbox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerUserId", wireType)
			}
			m.PeerUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerUserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInboxTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInboxTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &mtproto.Message{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInboxTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInboxTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLInboxEditChatMessageToInbox) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInboxTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_inbox_editChatMessageToInbox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_inbox_editChatMessageToInbox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerChatId", wireType)
			}
			m.PeerChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInboxTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInboxTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Message == nil {
				m.Message = &mtproto.Message{}
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInboxTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInboxTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLInboxDeleteMessagesToInbox) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInboxTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_inbox_deleteMessagesToInbox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_inbox_deleteMessagesToInbox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInboxTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Id = append(m.Id, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInboxTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthInboxTl
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthInboxTl
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Id) == 0 {
					m.Id = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInboxTl
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Id = append(m.Id, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInboxTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInboxTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLInboxDeleteUserHistoryToInbox) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInboxTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_inbox_deleteUserHistoryToInbox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_inbox_deleteUserHistoryToInbox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerUserId", wireType)
			}
			m.PeerUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerUserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JustClear", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.JustClear = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			m.MaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInboxTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInboxTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLInboxDeleteChatHistoryToInbox) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInboxTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_inbox_deleteChatHistoryToInbox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_inbox_deleteChatHistoryToInbox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerChatId", wireType)
			}
			m.PeerChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			m.MaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInboxTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInboxTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLInboxReadUserMediaUnreadToInbox) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInboxTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_inbox_readUserMediaUnreadToInbox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_inbox_readUserMediaUnreadToInbox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInboxTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Id = append(m.Id, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInboxTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthInboxTl
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthInboxTl
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Id) == 0 {
					m.Id = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInboxTl
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Id = append(m.Id, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInboxTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInboxTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLInboxReadChatMediaUnreadToInbox) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInboxTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_inbox_readChatMediaUnreadToInbox: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_inbox_readChatMediaUnreadToInbox: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerChatId", wireType)
			}
			m.PeerChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerChatId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInboxTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Id = append(m.Id, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInboxTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthInboxTl
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthInboxTl
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Id) == 0 {
					m.Id = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInboxTl
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Id = append(m.Id, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInboxTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInboxTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLInboxUpdateHistoryReaded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInboxTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_inbox_updateHistoryReaded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_inbox_updateHistoryReaded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			m.MaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			m.Sender = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sender |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInboxTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInboxTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLInboxUpdatePinnedMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInboxTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_inbox_updatePinnedMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_inbox_updatePinnedMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unpin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Unpin = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DialogMessageId", wireType)
			}
			m.DialogMessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DialogMessageId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInboxTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInboxTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLInboxUnpinAllMessages) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInboxTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_inbox_unpinAllMessages: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_inbox_unpinAllMessages: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInboxTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthInboxTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInboxTl(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInboxTl
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInboxTl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthInboxTl
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupInboxTl
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthInboxTl
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthInboxTl        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInboxTl          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupInboxTl = fmt.Errorf("proto: unexpected end of group")
)
